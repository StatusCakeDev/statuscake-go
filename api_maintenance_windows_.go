/*
 * StatusCake API
 *
 * Copyright (c) 2022
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * API version: 1.0.0-beta.1
 * Contact: support@statuscake.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package statuscake

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// Linger please
var _ context.Context

// MaintenanceWindowsAPI describes the necessary methods to adhere to this interface.
type MaintenanceWindowsAPI interface {
	CreateMaintenanceWindow(ctx context.Context) APICreateMaintenanceWindowRequest
	CreateMaintenanceWindowWithData(ctx context.Context, m map[string]interface{}) APICreateMaintenanceWindowRequest
	CreateMaintenanceWindowExecute(r APICreateMaintenanceWindowRequest) (APIResponse, error)
	DeleteMaintenanceWindow(ctx context.Context, windowId string) APIDeleteMaintenanceWindowRequest
	DeleteMaintenanceWindowExecute(r APIDeleteMaintenanceWindowRequest) error
	GetMaintenanceWindow(ctx context.Context, windowId string) APIGetMaintenanceWindowRequest
	GetMaintenanceWindowExecute(r APIGetMaintenanceWindowRequest) (MaintenanceWindowResponse, error)
	UpdateMaintenanceWindow(ctx context.Context, windowId string) APIUpdateMaintenanceWindowRequest
	UpdateMaintenanceWindowWithData(ctx context.Context, windowId string, m map[string]interface{}) APIUpdateMaintenanceWindowRequest
	UpdateMaintenanceWindowExecute(r APIUpdateMaintenanceWindowRequest) error
}

// MaintenanceWindowsService MaintenanceWindows service.
type MaintenanceWindowsService service

// APICreateMaintenanceWindowRequest represents a request type.
type APICreateMaintenanceWindowRequest struct {
	ctx            context.Context
	APIService     MaintenanceWindowsAPI
	name           *string
	endAt          *time.Time
	startAt        *time.Time
	timezone       *string
	repeatInterval *MaintenanceWindowRepeatInterval
	tags           *[]string
	tagsCsv        *string
	tests          *[]string
	testsCsv       *string
}

// Name sets name on the request type.
func (r APICreateMaintenanceWindowRequest) Name(name string) APICreateMaintenanceWindowRequest {
	r.name = &name
	return r
}

// End sets endAt on the request type.
func (r APICreateMaintenanceWindowRequest) End(endAt time.Time) APICreateMaintenanceWindowRequest {
	r.endAt = &endAt
	return r
}

// Start sets startAt on the request type.
func (r APICreateMaintenanceWindowRequest) Start(startAt time.Time) APICreateMaintenanceWindowRequest {
	r.startAt = &startAt
	return r
}

// Timezone sets timezone on the request type.
func (r APICreateMaintenanceWindowRequest) Timezone(timezone string) APICreateMaintenanceWindowRequest {
	r.timezone = &timezone
	return r
}

// RepeatInterval sets repeatInterval on the request type.
func (r APICreateMaintenanceWindowRequest) RepeatInterval(repeatInterval MaintenanceWindowRepeatInterval) APICreateMaintenanceWindowRequest {
	r.repeatInterval = &repeatInterval
	return r
}

// Tags sets tags on the request type.
func (r APICreateMaintenanceWindowRequest) Tags(tags []string) APICreateMaintenanceWindowRequest {
	r.tags = &tags
	return r
}

// TagsCsv sets tagsCsv on the request type.
func (r APICreateMaintenanceWindowRequest) TagsCsv(tagsCsv string) APICreateMaintenanceWindowRequest {
	r.tagsCsv = &tagsCsv
	return r
}

// Tests sets tests on the request type.
func (r APICreateMaintenanceWindowRequest) Tests(tests []string) APICreateMaintenanceWindowRequest {
	r.tests = &tests
	return r
}

// TestsCsv sets testsCsv on the request type.
func (r APICreateMaintenanceWindowRequest) TestsCsv(testsCsv string) APICreateMaintenanceWindowRequest {
	r.testsCsv = &testsCsv
	return r
}

// Execute executes the request.
func (r APICreateMaintenanceWindowRequest) Execute() (APIResponse, error) {
	return r.APIService.CreateMaintenanceWindowExecute(r)
}

// CreateMaintenanceWindow Create a maintenance window.
func (a *MaintenanceWindowsService) CreateMaintenanceWindow(ctx context.Context) APICreateMaintenanceWindowRequest {
	return APICreateMaintenanceWindowRequest{
		ctx:        ctx,
		APIService: a,
	}
}

// CreateMaintenanceWindowWithData Create a maintenance window.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *MaintenanceWindowsService) CreateMaintenanceWindowWithData(ctx context.Context, m map[string]interface{}) APICreateMaintenanceWindowRequest {
	r := a.CreateMaintenanceWindow(ctx)

	if prop, ok := m["name"].(string); ok {
		r.name = &prop
	}

	if prop, ok := m["end_at"].(time.Time); ok {
		r.endAt = &prop
	}

	if prop, ok := m["repeat_interval"].(MaintenanceWindowRepeatInterval); ok {
		r.repeatInterval = &prop
	}

	if prop, ok := m["start_at"].(time.Time); ok {
		r.startAt = &prop
	}

	if prop, ok := m["tags"].([]string); ok {
		r.tags = &prop
	}

	if prop, ok := m["tags_csv"].(string); ok {
		r.tagsCsv = &prop
	}

	if prop, ok := m["tests"].([]string); ok {
		r.tests = &prop
	}

	if prop, ok := m["tests_csv"].(string); ok {
		r.testsCsv = &prop
	}

	if prop, ok := m["timezone"].(string); ok {
		r.timezone = &prop
	}

	return r
}

// Execute executes the request.
func (a *MaintenanceWindowsService) CreateMaintenanceWindowExecute(r APICreateMaintenanceWindowRequest) (APIResponse, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          APIResponse
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "MaintenanceWindowsService.CreateMaintenanceWindow")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/maintenance-windows"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.name == nil {
		return returnValue, errorf("name is required and must be specified")
	}

	if r.endAt == nil {
		return returnValue, errorf("endAt is required and must be specified")
	}

	if r.startAt == nil {
		return returnValue, errorf("startAt is required and must be specified")
	}

	if r.timezone == nil {
		return returnValue, errorf("timezone is required and must be specified")
	}

	// Determine the Content-Type header.
	contentTypes := []string{"application/x-www-form-urlencoded"}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	formParams.Add("name", parameterToString(*r.name))
	formParams.Add("end_at", parameterToString(*r.endAt))

	if r.repeatInterval != nil {
		formParams.Add("repeat_interval", parameterToString(*r.repeatInterval))
	}
	formParams.Add("start_at", parameterToString(*r.startAt))

	if r.tags != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.tags) == 0 {
			formParams.Add("tags[]", "")
		}
		for _, val := range *r.tags {
			formParams.Add("tags[]", parameterToString(val))
		}
	}

	if r.tagsCsv != nil {
		formParams.Add("tags_csv", parameterToString(*r.tagsCsv))
	}

	if r.tests != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.tests) == 0 {
			formParams.Add("tests[]", "")
		}
		for _, val := range *r.tests {
			formParams.Add("tests[]", parameterToString(val))
		}
	}

	if r.testsCsv != nil {
		formParams.Add("tests_csv", parameterToString(*r.testsCsv))
	}
	formParams.Add("timezone", parameterToString(*r.timezone))
	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodPost, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIDeleteMaintenanceWindowRequest represents a request type.
type APIDeleteMaintenanceWindowRequest struct {
	ctx        context.Context
	APIService MaintenanceWindowsAPI
	windowId   string
}

// Execute executes the request.
func (r APIDeleteMaintenanceWindowRequest) Execute() error {
	return r.APIService.DeleteMaintenanceWindowExecute(r)
}

// DeleteMaintenanceWindow Delete a maintenance window.
func (a *MaintenanceWindowsService) DeleteMaintenanceWindow(ctx context.Context, windowId string) APIDeleteMaintenanceWindowRequest {
	return APIDeleteMaintenanceWindowRequest{
		ctx:        ctx,
		APIService: a,
		windowId:   windowId,
	}
}

// DeleteMaintenanceWindowWithData Delete a maintenance window.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *MaintenanceWindowsService) DeleteMaintenanceWindowWithData(ctx context.Context, windowId string, m map[string]interface{}) APIDeleteMaintenanceWindowRequest {
	r := a.DeleteMaintenanceWindow(ctx, windowId)
	return r
}

// Execute executes the request.
func (a *MaintenanceWindowsService) DeleteMaintenanceWindowExecute(r APIDeleteMaintenanceWindowRequest) error {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "MaintenanceWindowsService.DeleteMaintenanceWindow")
	if err != nil {
		return err
	}

	requestPath := basePath + "/maintenance-windows/{window_id}"
	requestPath = strings.Replace(requestPath, "{"+"window_id"+"}", url.PathEscape(parameterToString(r.windowId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodDelete, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return v
	}

	return nil
}

// APIGetMaintenanceWindowRequest represents a request type.
type APIGetMaintenanceWindowRequest struct {
	ctx        context.Context
	APIService MaintenanceWindowsAPI
	windowId   string
}

// Execute executes the request.
func (r APIGetMaintenanceWindowRequest) Execute() (MaintenanceWindowResponse, error) {
	return r.APIService.GetMaintenanceWindowExecute(r)
}

// GetMaintenanceWindow Retrieve a maintenance window.
func (a *MaintenanceWindowsService) GetMaintenanceWindow(ctx context.Context, windowId string) APIGetMaintenanceWindowRequest {
	return APIGetMaintenanceWindowRequest{
		ctx:        ctx,
		APIService: a,
		windowId:   windowId,
	}
}

// GetMaintenanceWindowWithData Retrieve a maintenance window.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *MaintenanceWindowsService) GetMaintenanceWindowWithData(ctx context.Context, windowId string, m map[string]interface{}) APIGetMaintenanceWindowRequest {
	r := a.GetMaintenanceWindow(ctx, windowId)
	return r
}

// Execute executes the request.
func (a *MaintenanceWindowsService) GetMaintenanceWindowExecute(r APIGetMaintenanceWindowRequest) (MaintenanceWindowResponse, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          MaintenanceWindowResponse
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "MaintenanceWindowsService.GetMaintenanceWindow")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/maintenance-windows/{window_id}"
	requestPath = strings.Replace(requestPath, "{"+"window_id"+"}", url.PathEscape(parameterToString(r.windowId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIUpdateMaintenanceWindowRequest represents a request type.
type APIUpdateMaintenanceWindowRequest struct {
	ctx            context.Context
	APIService     MaintenanceWindowsAPI
	windowId       string
	name           *string
	endAt          *time.Time
	repeatInterval *MaintenanceWindowRepeatInterval
	startAt        *time.Time
	tags           *[]string
	tagsCsv        *string
	tests          *[]string
	testsCsv       *string
	timezone       *string
}

// Name sets name on the request type.
func (r APIUpdateMaintenanceWindowRequest) Name(name string) APIUpdateMaintenanceWindowRequest {
	r.name = &name
	return r
}

// End sets endAt on the request type.
func (r APIUpdateMaintenanceWindowRequest) End(endAt time.Time) APIUpdateMaintenanceWindowRequest {
	r.endAt = &endAt
	return r
}

// RepeatInterval sets repeatInterval on the request type.
func (r APIUpdateMaintenanceWindowRequest) RepeatInterval(repeatInterval MaintenanceWindowRepeatInterval) APIUpdateMaintenanceWindowRequest {
	r.repeatInterval = &repeatInterval
	return r
}

// Start sets startAt on the request type.
func (r APIUpdateMaintenanceWindowRequest) Start(startAt time.Time) APIUpdateMaintenanceWindowRequest {
	r.startAt = &startAt
	return r
}

// Tags sets tags on the request type.
func (r APIUpdateMaintenanceWindowRequest) Tags(tags []string) APIUpdateMaintenanceWindowRequest {
	r.tags = &tags
	return r
}

// TagsCsv sets tagsCsv on the request type.
func (r APIUpdateMaintenanceWindowRequest) TagsCsv(tagsCsv string) APIUpdateMaintenanceWindowRequest {
	r.tagsCsv = &tagsCsv
	return r
}

// Tests sets tests on the request type.
func (r APIUpdateMaintenanceWindowRequest) Tests(tests []string) APIUpdateMaintenanceWindowRequest {
	r.tests = &tests
	return r
}

// TestsCsv sets testsCsv on the request type.
func (r APIUpdateMaintenanceWindowRequest) TestsCsv(testsCsv string) APIUpdateMaintenanceWindowRequest {
	r.testsCsv = &testsCsv
	return r
}

// Timezone sets timezone on the request type.
func (r APIUpdateMaintenanceWindowRequest) Timezone(timezone string) APIUpdateMaintenanceWindowRequest {
	r.timezone = &timezone
	return r
}

// Execute executes the request.
func (r APIUpdateMaintenanceWindowRequest) Execute() error {
	return r.APIService.UpdateMaintenanceWindowExecute(r)
}

// UpdateMaintenanceWindow Update a maintenance window.
func (a *MaintenanceWindowsService) UpdateMaintenanceWindow(ctx context.Context, windowId string) APIUpdateMaintenanceWindowRequest {
	return APIUpdateMaintenanceWindowRequest{
		ctx:        ctx,
		APIService: a,
		windowId:   windowId,
	}
}

// UpdateMaintenanceWindowWithData Update a maintenance window.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *MaintenanceWindowsService) UpdateMaintenanceWindowWithData(ctx context.Context, windowId string, m map[string]interface{}) APIUpdateMaintenanceWindowRequest {
	r := a.UpdateMaintenanceWindow(ctx, windowId)

	if prop, ok := m["name"].(string); ok {
		r.name = &prop
	}

	if prop, ok := m["end_at"].(time.Time); ok {
		r.endAt = &prop
	}

	if prop, ok := m["repeat_interval"].(MaintenanceWindowRepeatInterval); ok {
		r.repeatInterval = &prop
	}

	if prop, ok := m["start_at"].(time.Time); ok {
		r.startAt = &prop
	}

	if prop, ok := m["tags"].([]string); ok {
		r.tags = &prop
	}

	if prop, ok := m["tags_csv"].(string); ok {
		r.tagsCsv = &prop
	}

	if prop, ok := m["tests"].([]string); ok {
		r.tests = &prop
	}

	if prop, ok := m["tests_csv"].(string); ok {
		r.testsCsv = &prop
	}

	if prop, ok := m["timezone"].(string); ok {
		r.timezone = &prop
	}

	return r
}

// Execute executes the request.
func (a *MaintenanceWindowsService) UpdateMaintenanceWindowExecute(r APIUpdateMaintenanceWindowRequest) error {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "MaintenanceWindowsService.UpdateMaintenanceWindow")
	if err != nil {
		return err
	}

	requestPath := basePath + "/maintenance-windows/{window_id}"
	requestPath = strings.Replace(requestPath, "{"+"window_id"+"}", url.PathEscape(parameterToString(r.windowId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{"application/x-www-form-urlencoded"}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	if r.name != nil {
		formParams.Add("name", parameterToString(*r.name))
	}

	if r.endAt != nil {
		formParams.Add("end_at", parameterToString(*r.endAt))
	}

	if r.repeatInterval != nil {
		formParams.Add("repeat_interval", parameterToString(*r.repeatInterval))
	}

	if r.startAt != nil {
		formParams.Add("start_at", parameterToString(*r.startAt))
	}

	if r.tags != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.tags) == 0 {
			formParams.Add("tags[]", "")
		}
		for _, val := range *r.tags {
			formParams.Add("tags[]", parameterToString(val))
		}
	}

	if r.tagsCsv != nil {
		formParams.Add("tags_csv", parameterToString(*r.tagsCsv))
	}

	if r.tests != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.tests) == 0 {
			formParams.Add("tests[]", "")
		}
		for _, val := range *r.tests {
			formParams.Add("tests[]", parameterToString(val))
		}
	}

	if r.testsCsv != nil {
		formParams.Add("tests_csv", parameterToString(*r.testsCsv))
	}

	if r.timezone != nil {
		formParams.Add("timezone", parameterToString(*r.timezone))
	}
	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodPut, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return v
	}

	return nil
}
