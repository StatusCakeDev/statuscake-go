//go:build consumer
// +build consumer

/*
 * StatusCake API
 *
 * Copyright (c) 2022
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * API version: 1.0.0-beta.2
 * Contact: support@statuscake.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package statuscake_test

import (
	"context"
	"net/http"
	"testing"
	"time"

	"github.com/pact-foundation/pact-go/v2/matchers"
	. "github.com/pact-foundation/pact-go/v2/sugar"

	"github.com/StatusCakeDev/statuscake-go"
)

func TestCreateSSLTest(t *testing.T) {
	t.Run("returns a created status on success", func(t *testing.T) {
		mockProvider.
			AddInteraction().
			Given(ProviderStateV3{
				Name: "An existing contact group",
				Parameters: map[string]interface{}{
					"group_id": 123,
				},
			}).
			UponReceiving("A request to create a valid SSL test").
			WithRequest(http.MethodPost, S("/v1/ssl")).
			WithHeaders(matchers.HeadersMatcher{
				"Accept":        []Matcher{S("application/json")},
				"Authorization": []Matcher{S("Bearer 123456789")},
				"Content-Type":  []Matcher{S("application/x-www-form-urlencoded")},
			}).
			WithBody("application/x-www-form-urlencoded", []byte(
				"alert_at%5B%5D=1&"+
					"alert_at%5B%5D=7&"+
					"alert_at%5B%5D=30&"+
					"alert_broken=true&"+
					"alert_expiry=true&"+
					"alert_mixed=true&"+
					"alert_reminder=true&"+
					"check_rate=3600&"+
					"contact_groups%5B%5D=123&"+
					"follow_redirects=true&"+
					"hostname=svc.example.com&"+
					"paused=true&"+
					"user_agent=Mozilla%2F5.0+%28Macintosh%3B+Intel+Mac+OS+X+11_1%29+AppleWebKit%2F537.36+%28KHTML%2C+like+Gecko%29+Chrome%2F87.0.4280.141+Safari%2F537.36+OPR%2F73.0.3856.344&"+
					"website_url=https%3A%2F%2Fwww.statuscake.com",
			)).
			WillRespondWith(http.StatusCreated).
			WithHeader("Content-Type", S("application/json")).
			WithJSONBody(Map{
				"data": matchers.StructMatcher{
					"new_id": Like("1"),
				},
			})

		executeTest(t, func(c *statuscake.Client) error {
			res, _ := c.CreateSslTest(context.Background()).
				WebsiteURL("https://www.statuscake.com").
				CheckRate(statuscake.SSLTestCheckRateOneHour).
				AlertAt([]int32{1, 7, 30}).
				AlertBroken(true).
				AlertExpiry(true).
				AlertMixed(true).
				AlertReminder(true).
				ContactGroups([]string{
					"123",
				}).
				FollowRedirects(true).
				Hostname("svc.example.com").
				Paused(true).
				UserAgent("Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36 OPR/73.0.3856.344").
				Execute()

			return equal(res.Data.NewID, "1")
		})
	})

	t.Run("returns an error if the request fails", func(t *testing.T) {
		mockProvider.
			AddInteraction().
			UponReceiving("A request to create an invalid SSL test").
			WithRequest(http.MethodPost, S("/v1/ssl")).
			WithHeaders(matchers.HeadersMatcher{
				"Accept":        []Matcher{S("application/json")},
				"Authorization": []Matcher{S("Bearer 123456789")},
				"Content-Type":  []Matcher{S("application/x-www-form-urlencoded")},
			}).
			WithBody("application/x-www-form-urlencoded", []byte(
				"alert_at%5B%5D=1&"+
					"alert_at%5B%5D=7&"+
					"alert_at%5B%5D=30&"+
					"alert_broken=true&"+
					"alert_expiry=true&"+
					"alert_mixed=true&"+
					"alert_reminder=true&"+
					"check_rate=3600&"+
					"website_url=this%2Cis%2Cnot%2Cvalid",
			)).
			WillRespondWith(http.StatusBadRequest).
			WithHeader("Content-Type", S("application/json")).
			WithJSONBody(Map{
				"message": Like("The provided parameters are invalid. Check the errors output for detailed information."),
				"errors": matchers.StructMatcher{
					"website_url": EachLike("Website Url is not a valid URL", 1),
				},
			})

		executeTest(t, func(c *statuscake.Client) error {
			_, err := c.CreateSslTest(context.Background()).
				WebsiteURL("this,is,not,valid").
				CheckRate(statuscake.SSLTestCheckRateOneHour).
				AlertAt([]int32{1, 7, 30}).
				AlertBroken(true).
				AlertExpiry(true).
				AlertMixed(true).
				AlertReminder(true).
				Execute()

			return equal(err, statuscake.APIError{
				Status:  http.StatusBadRequest,
				Message: "The provided parameters are invalid. Check the errors output for detailed information.",
				Errors: map[string][]string{
					"website_url": []string{"Website Url is not a valid URL"},
				},
			})
		})
	})
}

func TestDeleteSSLTest(t *testing.T) {
	t.Run("returns a no content status on success", func(t *testing.T) {
		mockProvider.
			AddInteraction().
			Given(ProviderStateV3{
				Name: "An existing SSL test",
			}).
			UponReceiving("A request to delete an SSL test").
			WithRequest(http.MethodDelete, FromProviderState("/v1/ssl/${id}", "/v1/ssl/1")).
			WithHeaders(matchers.HeadersMatcher{
				"Accept":        []Matcher{S("application/json")},
				"Authorization": []Matcher{S("Bearer 123456789")},
			}).
			WillRespondWith(http.StatusNoContent)

		executeTest(t, func(c *statuscake.Client) error {
			return c.DeleteSslTest(context.Background(), "1").Execute()
		})
	})

	t.Run("returns an error when the SSL test does not exist", func(t *testing.T) {
		mockProvider.
			AddInteraction().
			UponReceiving("A request to delete an SSL test").
			WithRequest(http.MethodDelete, S("/v1/ssl/2")).
			WithHeaders(matchers.HeadersMatcher{
				"Accept":        []Matcher{S("application/json")},
				"Authorization": []Matcher{S("Bearer 123456789")},
			}).
			WillRespondWith(http.StatusNotFound).
			WithHeader("Content-Type", S("application/json")).
			WithJSONBody(Map{
				"message": Like("No results found"),
				"errors":  matchers.StructMatcher{},
			})

		executeTest(t, func(c *statuscake.Client) error {
			err := c.DeleteSslTest(context.Background(), "2").Execute()
			return equal(err, statuscake.APIError{
				Status:  http.StatusNotFound,
				Message: "No results found",
				Errors:  map[string][]string{},
			})
		})
	})
}

func TestGetSSLTest(t *testing.T) {
	t.Run("returns an SSL test on success", func(t *testing.T) {
		mockProvider.
			AddInteraction().
			Given(ProviderStateV3{
				Name: "An existing SSL test and contact group",
			}).
			UponReceiving("A request to get an SSL test").
			WithRequest(http.MethodGet, FromProviderState("/v1/ssl/${id}", "/v1/ssl/1")).
			WithHeaders(matchers.HeadersMatcher{
				"Accept":        []Matcher{S("application/json")},
				"Authorization": []Matcher{S("Bearer 123456789")},
			}).
			WillRespondWith(http.StatusOK).
			WithHeader("Content-Type", S("application/json")).
			WithJSONBody(Map{
				"data": matchers.StructMatcher{
					"id":                 FromProviderState("${id}", "1"),
					"website_url":        Like("https://www.statuscake.com"),
					"check_rate":         Integer(3600),
					"alert_at":           ArrayMinMaxLike(1, 3, 3),
					"alert_broken":       Like(true),
					"alert_expiry":       Like(true),
					"alert_mixed":        Like(true),
					"alert_reminder":     Like(true),
					"certificate_score":  Integer(95),
					"certificate_status": Like("CERT_OK"),
					"cipher":             Like("TLS_CHACHA20_POLY1305_SHA256"),
					"cipher_score":       Integer(100),
					"contact_groups":     EachLike("123", 1),
					"flags": matchers.StructMatcher{
						"is_extended":      Like(false),
						"has_pfs":          Like(false),
						"is_broken":        Like(false),
						"is_expired":       Like(false),
						"is_missing":       Like(false),
						"is_revoked":       Like(false),
						"has_mixed":        Like(false),
						"follow_redirects": Like(true),
					},
					"follow_redirects":   Like(true),
					"hostname":           Like("svc.example.com"),
					"issuer_common_name": Like("Sectigo RSA Domain Validation Secure Server CA"),
					"last_reminder":      Integer(0),
					"mixed_content": EachLike(
						Map{
							"type": Like("img"),
							"src":  Like("http://www.example.com/public/images/teapot.png"),
						}, 1,
					),
					"paused":      Like(true),
					"updated_at":  Timestamp(),
					"user_agent":  Like("Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36 OPR/73.0.3856.344"),
					"valid_from":  Timestamp(),
					"valid_until": Timestamp(),
				},
			})

		executeTest(t, func(c *statuscake.Client) error {
			test, _ := c.GetSslTest(context.Background(), "1").Execute()
			return equal(test.Data, statuscake.SSLTest{
				ID:                "1",
				WebsiteURL:        "https://www.statuscake.com",
				CheckRate:         statuscake.SSLTestCheckRateOneHour,
				AlertAt:           []int32{1, 1, 1},
				AlertBroken:       true,
				AlertExpiry:       true,
				AlertMixed:        true,
				AlertReminder:     true,
				CertificateScore:  statuscake.PtrInt32(95),
				CertificateStatus: statuscake.PtrString("CERT_OK"),
				Cipher:            statuscake.PtrString("TLS_CHACHA20_POLY1305_SHA256"),
				CipherScore:       statuscake.PtrInt32(100),
				ContactGroups: []string{
					"123",
				},
				Flags: &statuscake.SSLTestFlags{
					FollowRedirects: true,
				},
				FollowRedirects:  true,
				Hostname:         statuscake.PtrString("svc.example.com"),
				IssuerCommonName: statuscake.PtrString("Sectigo RSA Domain Validation Secure Server CA"),
				LastReminder:     statuscake.PtrInt32(0),
				MixedContent: []statuscake.SSLTestMixedContent{
					statuscake.SSLTestMixedContent{
						Type: "img",
						URL:  "http://www.example.com/public/images/teapot.png",
					},
				},
				Paused:     true,
				Updated:    statuscake.PtrTime(time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)),
				UserAgent:  statuscake.PtrString("Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36 OPR/73.0.3856.344"),
				ValidFrom:  statuscake.PtrTime(time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)),
				ValidUntil: statuscake.PtrTime(time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)),
			})
		})
	})

	t.Run("returns an error when the SSL test does not exist", func(t *testing.T) {
		mockProvider.
			AddInteraction().
			UponReceiving("A request to get an SSL test").
			WithRequest(http.MethodGet, S("/v1/ssl/2")).
			WithHeaders(matchers.HeadersMatcher{
				"Accept":        []Matcher{S("application/json")},
				"Authorization": []Matcher{S("Bearer 123456789")},
			}).
			WillRespondWith(http.StatusNotFound).
			WithHeader("Content-Type", S("application/json")).
			WithJSONBody(Map{
				"message": Like("No results found"),
				"errors":  matchers.StructMatcher{},
			})

		executeTest(t, func(c *statuscake.Client) error {
			_, err := c.GetSslTest(context.Background(), "2").Execute()
			return equal(err, statuscake.APIError{
				Status:  http.StatusNotFound,
				Message: "No results found",
				Errors:  map[string][]string{},
			})
		})
	})
}

func TestListSSLTests(t *testing.T) {
	t.Run("returns a list of SSL tests on success", func(t *testing.T) {
		mockProvider.
			AddInteraction().
			Given(ProviderStateV3{
				Name: "Existing SSL tests and contact group",
			}).
			UponReceiving("A request to get a list of SSL tests").
			WithRequest(http.MethodGet, S("/v1/ssl")).
			WithHeaders(matchers.HeadersMatcher{
				"Accept":        []Matcher{S("application/json")},
				"Authorization": []Matcher{S("Bearer 123456789")},
			}).
			WillRespondWith(http.StatusOK).
			WithHeader("Content-Type", S("application/json")).
			WithJSONBody(Map{
				"data": EachLike(
					matchers.StructMatcher{
						"id":                 FromProviderState("${id}", "1"),
						"website_url":        Like("https://www.statuscake.com"),
						"check_rate":         Integer(3600),
						"alert_at":           ArrayMinMaxLike(1, 3, 3),
						"alert_broken":       Like(true),
						"alert_expiry":       Like(true),
						"alert_mixed":        Like(true),
						"alert_reminder":     Like(true),
						"certificate_score":  Integer(95),
						"certificate_status": Like("CERT_OK"),
						"cipher":             Like("TLS_CHACHA20_POLY1305_SHA256"),
						"cipher_score":       Integer(100),
						"contact_groups":     EachLike("123", 1),
						"flags": matchers.StructMatcher{
							"is_extended":      Like(false),
							"has_pfs":          Like(false),
							"is_broken":        Like(false),
							"is_expired":       Like(false),
							"is_missing":       Like(false),
							"is_revoked":       Like(false),
							"has_mixed":        Like(false),
							"follow_redirects": Like(true),
						},
						"follow_redirects":   Like(true),
						"hostname":           Like("svc.example.com"),
						"issuer_common_name": Like("Sectigo RSA Domain Validation Secure Server CA"),
						"last_reminder":      Integer(0),
						"mixed_content": EachLike(
							Map{
								"type": Like("img"),
								"src":  Like("http://www.example.com/public/images/teapot.png"),
							}, 1,
						),
						"paused":      Like(true),
						"updated_at":  Timestamp(),
						"user_agent":  Like("Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36 OPR/73.0.3856.344"),
						"valid_from":  Timestamp(),
						"valid_until": Timestamp(),
					}, 1,
				),
				"metadata": matchers.StructMatcher{
					"page":        Like(1),
					"per_page":    Like(25),
					"page_count":  Like(1),
					"total_count": Like(5),
				},
			})

		executeTest(t, func(c *statuscake.Client) error {
			tests, _ := c.ListSslTests(context.Background()).Execute()
			return equal(tests.Data, []statuscake.SSLTest{
				statuscake.SSLTest{
					ID:                "1",
					WebsiteURL:        "https://www.statuscake.com",
					CheckRate:         statuscake.SSLTestCheckRateOneHour,
					AlertAt:           []int32{1, 1, 1},
					AlertBroken:       true,
					AlertExpiry:       true,
					AlertMixed:        true,
					AlertReminder:     true,
					CertificateScore:  statuscake.PtrInt32(95),
					CertificateStatus: statuscake.PtrString("CERT_OK"),
					Cipher:            statuscake.PtrString("TLS_CHACHA20_POLY1305_SHA256"),
					CipherScore:       statuscake.PtrInt32(100),
					ContactGroups: []string{
						"123",
					},
					Flags: &statuscake.SSLTestFlags{
						FollowRedirects: true,
					},
					FollowRedirects:  true,
					Hostname:         statuscake.PtrString("svc.example.com"),
					IssuerCommonName: statuscake.PtrString("Sectigo RSA Domain Validation Secure Server CA"),
					LastReminder:     statuscake.PtrInt32(0),
					MixedContent: []statuscake.SSLTestMixedContent{
						statuscake.SSLTestMixedContent{
							Type: "img",
							URL:  "http://www.example.com/public/images/teapot.png",
						},
					},
					Paused:     true,
					Updated:    statuscake.PtrTime(time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)),
					UserAgent:  statuscake.PtrString("Mozilla/5.0 (Macintosh; Intel Mac OS X 11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36 OPR/73.0.3856.344"),
					ValidFrom:  statuscake.PtrTime(time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)),
					ValidUntil: statuscake.PtrTime(time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)),
				},
			})
		})
	})

	t.Run("returns an empty list when there are no SSL tests", func(t *testing.T) {
		mockProvider.
			AddInteraction().
			UponReceiving("A request to get a list of SSL tests").
			WithRequest(http.MethodGet, S("/v1/ssl")).
			WithHeaders(matchers.HeadersMatcher{
				"Accept":        []Matcher{S("application/json")},
				"Authorization": []Matcher{S("Bearer 123456789")},
			}).
			WillRespondWith(http.StatusOK).
			WithHeader("Content-Type", S("application/json")).
			WithJSONBody(Map{
				"data": Like([]interface{}{}),
				"metadata": matchers.StructMatcher{
					"page":        Like(1),
					"per_page":    Like(25),
					"page_count":  Like(1),
					"total_count": 0,
				},
			})

		executeTest(t, func(c *statuscake.Client) error {
			tests, _ := c.ListSslTests(context.Background()).Execute()
			return equal(tests.Data, []statuscake.SSLTest{})
		})
	})
}

func TestUpdateSSLTest(t *testing.T) {
	t.Run("returns a no content status on success", func(t *testing.T) {
		mockProvider.
			AddInteraction().
			Given(ProviderStateV3{
				Name: "An existing SSL test",
			}).
			UponReceiving("A request to update an SSL test").
			WithRequest(http.MethodPut, FromProviderState("/v1/ssl/${id}", "/v1/ssl/1")).
			WithHeaders(matchers.HeadersMatcher{
				"Accept":        []Matcher{S("application/json")},
				"Authorization": []Matcher{S("Bearer 123456789")},
				"Content-Type":  []Matcher{S("application/x-www-form-urlencoded")},
			}).
			WithBody("application/x-www-form-urlencoded", []byte(
				"alert_at%5B%5D=1&"+
					"alert_at%5B%5D=14&"+
					"alert_at%5B%5D=25&"+
					"alert_broken=false&"+
					"alert_expiry=false&"+
					"alert_mixed=false&"+
					"alert_reminder=false&"+
					"check_rate=1800&"+
					"contact_groups%5B%5D=&"+
					"follow_redirects=false&"+
					"paused=false",
			)).
			WillRespondWith(http.StatusNoContent)

		executeTest(t, func(c *statuscake.Client) error {
			return c.UpdateSslTest(context.Background(), "1").
				CheckRate(statuscake.SSLTestCheckRateThirtyMinutes).
				AlertAt([]int32{1, 14, 25}).
				AlertBroken(false).
				AlertExpiry(false).
				AlertMixed(false).
				AlertReminder(false).
				ContactGroups([]string{}).
				FollowRedirects(false).
				Paused(false).
				Execute()
		})
	})

	t.Run("returns an error if the request fails", func(t *testing.T) {
		mockProvider.
			AddInteraction().
			Given(ProviderStateV3{
				Name: "An existing SSL test",
			}).
			UponReceiving("A request to update an invalid SSL test").
			WithRequest(http.MethodPut, FromProviderState("/v1/ssl/${id}", "/v1/ssl/1")).
			WithHeaders(matchers.HeadersMatcher{
				"Accept":        []Matcher{S("application/json")},
				"Authorization": []Matcher{S("Bearer 123456789")},
				"Content-Type":  []Matcher{S("application/x-www-form-urlencoded")},
			}).
			WithBody("application/x-www-form-urlencoded", []byte(
				"alert_at%5B%5D=10",
			)).
			WillRespondWith(http.StatusBadRequest).
			WithHeader("Content-Type", S("application/json")).
			WithJSONBody(Map{
				"message": Like("alert_at must have exactly 3 numeric parameters."),
				"errors":  matchers.StructMatcher{},
			})

		executeTest(t, func(c *statuscake.Client) error {
			err := c.UpdateSslTest(context.Background(), "1").
				AlertAt([]int32{10}).
				Execute()

			return equal(err, statuscake.APIError{
				Status:  http.StatusBadRequest,
				Message: "alert_at must have exactly 3 numeric parameters.",
				Errors:  map[string][]string{},
			})
		})
	})

	t.Run("returns an error when the SSL test does not exist", func(t *testing.T) {
		mockProvider.
			AddInteraction().
			UponReceiving("A request to update an SSL test").
			WithRequest(http.MethodPut, S("/v1/ssl/2")).
			WithHeaders(matchers.HeadersMatcher{
				"Accept":        []Matcher{S("application/json")},
				"Authorization": []Matcher{S("Bearer 123456789")},
				"Content-Type":  []Matcher{S("application/x-www-form-urlencoded")},
			}).
			WithBody("application/x-www-form-urlencoded", []byte(
				"paused=false",
			)).
			WillRespondWith(http.StatusNotFound).
			WithHeader("Content-Type", S("application/json")).
			WithJSONBody(Map{
				"message": Like("No results found"),
				"errors":  matchers.StructMatcher{},
			})

		executeTest(t, func(c *statuscake.Client) error {
			err := c.UpdateSslTest(context.Background(), "2").
				Paused(false).
				Execute()

			return equal(err, statuscake.APIError{
				Status:  http.StatusNotFound,
				Message: "No results found",
				Errors:  map[string][]string{},
			})
		})
	})
}
