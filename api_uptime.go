/*
 * StatusCake API
 *
 * Copyright (c) 2022
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * API version: 1.0.0-beta.1
 * Contact: support@statuscake.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package statuscake

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var _ context.Context

// UptimeAPI describes the necessary methods to adhere to this interface.
type UptimeAPI interface {
	CreateUptimeTest(ctx context.Context) APICreateUptimeTestRequest
	CreateUptimeTestWithData(ctx context.Context, m map[string]interface{}) APICreateUptimeTestRequest
	CreateUptimeTestExecute(r APICreateUptimeTestRequest) (APIResponse, error)
	DeleteUptimeTest(ctx context.Context, testId string) APIDeleteUptimeTestRequest
	DeleteUptimeTestExecute(r APIDeleteUptimeTestRequest) error
	GetUptimeTest(ctx context.Context, testId string) APIGetUptimeTestRequest
	GetUptimeTestExecute(r APIGetUptimeTestRequest) (UptimeTestResponse, error)
	ListMaintenanceWindows(ctx context.Context) APIListMaintenanceWindowsRequest
	ListMaintenanceWindowsExecute(r APIListMaintenanceWindowsRequest) (MaintenanceWindows, error)
	ListUptimeTestAlerts(ctx context.Context, testId string) APIListUptimeTestAlertsRequest
	ListUptimeTestAlertsExecute(r APIListUptimeTestAlertsRequest) (UptimeTestAlerts, error)
	ListUptimeTestHistory(ctx context.Context, testId string) APIListUptimeTestHistoryRequest
	ListUptimeTestHistoryExecute(r APIListUptimeTestHistoryRequest) (UptimeTestHistory, error)
	ListUptimeTestPeriods(ctx context.Context, testId string) APIListUptimeTestPeriodsRequest
	ListUptimeTestPeriodsExecute(r APIListUptimeTestPeriodsRequest) (UptimeTestPeriods, error)
	ListUptimeTests(ctx context.Context) APIListUptimeTestsRequest
	ListUptimeTestsExecute(r APIListUptimeTestsRequest) (UptimeTests, error)
	UpdateUptimeTest(ctx context.Context, testId string) APIUpdateUptimeTestRequest
	UpdateUptimeTestWithData(ctx context.Context, testId string, m map[string]interface{}) APIUpdateUptimeTestRequest
	UpdateUptimeTestExecute(r APIUpdateUptimeTestRequest) error
}

// UptimeService Uptime service.
type UptimeService service

// APICreateUptimeTestRequest represents a request type.
type APICreateUptimeTestRequest struct {
	ctx              context.Context
	APIService       UptimeAPI
	name             *string
	testType         *UptimeTestType
	websiteUrl       *string
	checkRate        *UptimeTestCheckRate
	basicUsername    *string
	basicPassword    *string
	confirmation     *int32
	contactGroups    *[]string
	contactGroupsCsv *string
	customHeader     *string
	doNotFind        *bool
	dnsIps           *[]string
	dnsIpsCsv        *string
	dnsServer        *string
	enableSslAlert   *bool
	finalEndpoint    *string
	findString       *string
	followRedirects  *bool
	host             *string
	includeHeader    *bool
	paused           *bool
	port             *int32
	postBody         *string
	postRaw          *string
	regions          *[]string
	statusCodesCsv   *string
	tags             *[]string
	tagsCsv          *string
	timeout          *int32
	triggerRate      *int32
	useJar           *bool
	userAgent        *string
}

// Name sets name on the request type.
func (r APICreateUptimeTestRequest) Name(name string) APICreateUptimeTestRequest {
	r.name = &name
	return r
}

// TestType sets testType on the request type.
func (r APICreateUptimeTestRequest) TestType(testType UptimeTestType) APICreateUptimeTestRequest {
	r.testType = &testType
	return r
}

// WebsiteURL sets websiteUrl on the request type.
func (r APICreateUptimeTestRequest) WebsiteURL(websiteUrl string) APICreateUptimeTestRequest {
	r.websiteUrl = &websiteUrl
	return r
}

// CheckRate sets checkRate on the request type.
func (r APICreateUptimeTestRequest) CheckRate(checkRate UptimeTestCheckRate) APICreateUptimeTestRequest {
	r.checkRate = &checkRate
	return r
}

// BasicUsername sets basicUsername on the request type.
func (r APICreateUptimeTestRequest) BasicUsername(basicUsername string) APICreateUptimeTestRequest {
	r.basicUsername = &basicUsername
	return r
}

// BasicPassword sets basicPassword on the request type.
func (r APICreateUptimeTestRequest) BasicPassword(basicPassword string) APICreateUptimeTestRequest {
	r.basicPassword = &basicPassword
	return r
}

// Confirmation sets confirmation on the request type.
func (r APICreateUptimeTestRequest) Confirmation(confirmation int32) APICreateUptimeTestRequest {
	r.confirmation = &confirmation
	return r
}

// ContactGroups sets contactGroups on the request type.
func (r APICreateUptimeTestRequest) ContactGroups(contactGroups []string) APICreateUptimeTestRequest {
	r.contactGroups = &contactGroups
	return r
}

// ContactGroupsCsv sets contactGroupsCsv on the request type.
func (r APICreateUptimeTestRequest) ContactGroupsCsv(contactGroupsCsv string) APICreateUptimeTestRequest {
	r.contactGroupsCsv = &contactGroupsCsv
	return r
}

// CustomHeader sets customHeader on the request type.
func (r APICreateUptimeTestRequest) CustomHeader(customHeader string) APICreateUptimeTestRequest {
	r.customHeader = &customHeader
	return r
}

// DoNotFind sets doNotFind on the request type.
func (r APICreateUptimeTestRequest) DoNotFind(doNotFind bool) APICreateUptimeTestRequest {
	r.doNotFind = &doNotFind
	return r
}

// DNSIPs sets dnsIps on the request type.
func (r APICreateUptimeTestRequest) DNSIPs(dnsIps []string) APICreateUptimeTestRequest {
	r.dnsIps = &dnsIps
	return r
}

// DnsIpsCsv sets dnsIpsCsv on the request type.
func (r APICreateUptimeTestRequest) DnsIpsCsv(dnsIpsCsv string) APICreateUptimeTestRequest {
	r.dnsIpsCsv = &dnsIpsCsv
	return r
}

// DNSServer sets dnsServer on the request type.
func (r APICreateUptimeTestRequest) DNSServer(dnsServer string) APICreateUptimeTestRequest {
	r.dnsServer = &dnsServer
	return r
}

// EnableSSLAlert sets enableSslAlert on the request type.
func (r APICreateUptimeTestRequest) EnableSSLAlert(enableSslAlert bool) APICreateUptimeTestRequest {
	r.enableSslAlert = &enableSslAlert
	return r
}

// FinalEndpoint sets finalEndpoint on the request type.
func (r APICreateUptimeTestRequest) FinalEndpoint(finalEndpoint string) APICreateUptimeTestRequest {
	r.finalEndpoint = &finalEndpoint
	return r
}

// FindString sets findString on the request type.
func (r APICreateUptimeTestRequest) FindString(findString string) APICreateUptimeTestRequest {
	r.findString = &findString
	return r
}

// FollowRedirects sets followRedirects on the request type.
func (r APICreateUptimeTestRequest) FollowRedirects(followRedirects bool) APICreateUptimeTestRequest {
	r.followRedirects = &followRedirects
	return r
}

// Host sets host on the request type.
func (r APICreateUptimeTestRequest) Host(host string) APICreateUptimeTestRequest {
	r.host = &host
	return r
}

// IncludeHeader sets includeHeader on the request type.
func (r APICreateUptimeTestRequest) IncludeHeader(includeHeader bool) APICreateUptimeTestRequest {
	r.includeHeader = &includeHeader
	return r
}

// Paused sets paused on the request type.
func (r APICreateUptimeTestRequest) Paused(paused bool) APICreateUptimeTestRequest {
	r.paused = &paused
	return r
}

// Port sets port on the request type.
func (r APICreateUptimeTestRequest) Port(port int32) APICreateUptimeTestRequest {
	r.port = &port
	return r
}

// PostBody sets postBody on the request type.
func (r APICreateUptimeTestRequest) PostBody(postBody string) APICreateUptimeTestRequest {
	r.postBody = &postBody
	return r
}

// PostRaw sets postRaw on the request type.
func (r APICreateUptimeTestRequest) PostRaw(postRaw string) APICreateUptimeTestRequest {
	r.postRaw = &postRaw
	return r
}

// Regions sets regions on the request type.
func (r APICreateUptimeTestRequest) Regions(regions []string) APICreateUptimeTestRequest {
	r.regions = &regions
	return r
}

// StatusCodes sets statusCodesCsv on the request type.
func (r APICreateUptimeTestRequest) StatusCodes(statusCodesCsv []string) APICreateUptimeTestRequest {
	r.statusCodesCsv = PtrString(strings.Join(statusCodesCsv, ","))
	return r
}

// Tags sets tags on the request type.
func (r APICreateUptimeTestRequest) Tags(tags []string) APICreateUptimeTestRequest {
	r.tags = &tags
	return r
}

// TagsCsv sets tagsCsv on the request type.
func (r APICreateUptimeTestRequest) TagsCsv(tagsCsv string) APICreateUptimeTestRequest {
	r.tagsCsv = &tagsCsv
	return r
}

// Timeout sets timeout on the request type.
func (r APICreateUptimeTestRequest) Timeout(timeout int32) APICreateUptimeTestRequest {
	r.timeout = &timeout
	return r
}

// TriggerRate sets triggerRate on the request type.
func (r APICreateUptimeTestRequest) TriggerRate(triggerRate int32) APICreateUptimeTestRequest {
	r.triggerRate = &triggerRate
	return r
}

// UseJAR sets useJar on the request type.
func (r APICreateUptimeTestRequest) UseJAR(useJar bool) APICreateUptimeTestRequest {
	r.useJar = &useJar
	return r
}

// UserAgent sets userAgent on the request type.
func (r APICreateUptimeTestRequest) UserAgent(userAgent string) APICreateUptimeTestRequest {
	r.userAgent = &userAgent
	return r
}

// Execute executes the request.
func (r APICreateUptimeTestRequest) Execute() (APIResponse, error) {
	return r.APIService.CreateUptimeTestExecute(r)
}

// CreateUptimeTest Create an uptime check.
func (a *UptimeService) CreateUptimeTest(ctx context.Context) APICreateUptimeTestRequest {
	return APICreateUptimeTestRequest{
		ctx:        ctx,
		APIService: a,
	}
}

// CreateUptimeTestWithData Create an uptime check.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *UptimeService) CreateUptimeTestWithData(ctx context.Context, m map[string]interface{}) APICreateUptimeTestRequest {
	r := a.CreateUptimeTest(ctx)

	if prop, ok := m["name"].(string); ok {
		r.name = &prop
	}

	if prop, ok := m["test_type"].(UptimeTestType); ok {
		r.testType = &prop
	}

	if prop, ok := m["website_url"].(string); ok {
		r.websiteUrl = &prop
	}

	if prop, ok := m["check_rate"].(UptimeTestCheckRate); ok {
		r.checkRate = &prop
	}

	if prop, ok := m["basic_username"].(string); ok {
		r.basicUsername = &prop
	}

	if prop, ok := m["basic_password"].(string); ok {
		r.basicPassword = &prop
	}

	if prop, ok := m["confirmation"].(int32); ok {
		r.confirmation = &prop
	}

	if prop, ok := m["contact_groups"].([]string); ok {
		r.contactGroups = &prop
	}

	if prop, ok := m["contact_groups_csv"].(string); ok {
		r.contactGroupsCsv = &prop
	}

	if prop, ok := m["custom_header"].(string); ok {
		r.customHeader = &prop
	}

	if prop, ok := m["do_not_find"].(bool); ok {
		r.doNotFind = &prop
	}

	if prop, ok := m["dns_ips"].([]string); ok {
		r.dnsIps = &prop
	}

	if prop, ok := m["dns_ips_csv"].(string); ok {
		r.dnsIpsCsv = &prop
	}

	if prop, ok := m["dns_server"].(string); ok {
		r.dnsServer = &prop
	}

	if prop, ok := m["enable_ssl_alert"].(bool); ok {
		r.enableSslAlert = &prop
	}

	if prop, ok := m["final_endpoint"].(string); ok {
		r.finalEndpoint = &prop
	}

	if prop, ok := m["find_string"].(string); ok {
		r.findString = &prop
	}

	if prop, ok := m["follow_redirects"].(bool); ok {
		r.followRedirects = &prop
	}

	if prop, ok := m["host"].(string); ok {
		r.host = &prop
	}

	if prop, ok := m["include_header"].(bool); ok {
		r.includeHeader = &prop
	}

	if prop, ok := m["paused"].(bool); ok {
		r.paused = &prop
	}

	if prop, ok := m["port"].(int32); ok {
		r.port = &prop
	}

	if prop, ok := m["post_body"].(string); ok {
		r.postBody = &prop
	}

	if prop, ok := m["post_raw"].(string); ok {
		r.postRaw = &prop
	}

	if prop, ok := m["regions"].([]string); ok {
		r.regions = &prop
	}

	if prop, ok := m["status_codes_csv"].(string); ok {
		r.statusCodesCsv = &prop
	}

	if prop, ok := m["tags"].([]string); ok {
		r.tags = &prop
	}

	if prop, ok := m["tags_csv"].(string); ok {
		r.tagsCsv = &prop
	}

	if prop, ok := m["timeout"].(int32); ok {
		r.timeout = &prop
	}

	if prop, ok := m["trigger_rate"].(int32); ok {
		r.triggerRate = &prop
	}

	if prop, ok := m["use_jar"].(bool); ok {
		r.useJar = &prop
	}

	if prop, ok := m["user_agent"].(string); ok {
		r.userAgent = &prop
	}

	return r
}

// Execute executes the request.
func (a *UptimeService) CreateUptimeTestExecute(r APICreateUptimeTestRequest) (APIResponse, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          APIResponse
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "UptimeService.CreateUptimeTest")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.name == nil {
		return returnValue, errorf("name is required and must be specified")
	}

	if r.testType == nil {
		return returnValue, errorf("testType is required and must be specified")
	}

	if r.websiteUrl == nil {
		return returnValue, errorf("websiteUrl is required and must be specified")
	}

	if r.checkRate == nil {
		return returnValue, errorf("checkRate is required and must be specified")
	}

	// Determine the Content-Type header.
	contentTypes := []string{"application/x-www-form-urlencoded"}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	formParams.Add("name", parameterToString(*r.name))
	formParams.Add("test_type", parameterToString(*r.testType))
	formParams.Add("website_url", parameterToString(*r.websiteUrl))
	formParams.Add("check_rate", parameterToString(*r.checkRate))

	if r.basicUsername != nil {
		formParams.Add("basic_username", parameterToString(*r.basicUsername))
	}

	if r.basicPassword != nil {
		formParams.Add("basic_password", parameterToString(*r.basicPassword))
	}

	if r.confirmation != nil {
		formParams.Add("confirmation", parameterToString(*r.confirmation))
	}

	if r.contactGroups != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.contactGroups) == 0 {
			formParams.Add("contact_groups[]", "")
		}
		for _, val := range *r.contactGroups {
			formParams.Add("contact_groups[]", parameterToString(val))
		}
	}

	if r.contactGroupsCsv != nil {
		formParams.Add("contact_groups_csv", parameterToString(*r.contactGroupsCsv))
	}

	if r.customHeader != nil {
		formParams.Add("custom_header", parameterToString(*r.customHeader))
	}

	if r.doNotFind != nil {
		formParams.Add("do_not_find", parameterToString(*r.doNotFind))
	}

	if r.dnsIps != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.dnsIps) == 0 {
			formParams.Add("dns_ips[]", "")
		}
		for _, val := range *r.dnsIps {
			formParams.Add("dns_ips[]", parameterToString(val))
		}
	}

	if r.dnsIpsCsv != nil {
		formParams.Add("dns_ips_csv", parameterToString(*r.dnsIpsCsv))
	}

	if r.dnsServer != nil {
		formParams.Add("dns_server", parameterToString(*r.dnsServer))
	}

	if r.enableSslAlert != nil {
		formParams.Add("enable_ssl_alert", parameterToString(*r.enableSslAlert))
	}

	if r.finalEndpoint != nil {
		formParams.Add("final_endpoint", parameterToString(*r.finalEndpoint))
	}

	if r.findString != nil {
		formParams.Add("find_string", parameterToString(*r.findString))
	}

	if r.followRedirects != nil {
		formParams.Add("follow_redirects", parameterToString(*r.followRedirects))
	}

	if r.host != nil {
		formParams.Add("host", parameterToString(*r.host))
	}

	if r.includeHeader != nil {
		formParams.Add("include_header", parameterToString(*r.includeHeader))
	}

	if r.paused != nil {
		formParams.Add("paused", parameterToString(*r.paused))
	}

	if r.port != nil {
		formParams.Add("port", parameterToString(*r.port))
	}

	if r.postBody != nil {
		formParams.Add("post_body", parameterToString(*r.postBody))
	}

	if r.postRaw != nil {
		formParams.Add("post_raw", parameterToString(*r.postRaw))
	}

	if r.regions != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.regions) == 0 {
			formParams.Add("regions[]", "")
		}
		for _, val := range *r.regions {
			formParams.Add("regions[]", parameterToString(val))
		}
	}

	if r.statusCodesCsv != nil {
		formParams.Add("status_codes_csv", parameterToString(*r.statusCodesCsv))
	}

	if r.tags != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.tags) == 0 {
			formParams.Add("tags[]", "")
		}
		for _, val := range *r.tags {
			formParams.Add("tags[]", parameterToString(val))
		}
	}

	if r.tagsCsv != nil {
		formParams.Add("tags_csv", parameterToString(*r.tagsCsv))
	}

	if r.timeout != nil {
		formParams.Add("timeout", parameterToString(*r.timeout))
	}

	if r.triggerRate != nil {
		formParams.Add("trigger_rate", parameterToString(*r.triggerRate))
	}

	if r.useJar != nil {
		formParams.Add("use_jar", parameterToString(*r.useJar))
	}

	if r.userAgent != nil {
		formParams.Add("user_agent", parameterToString(*r.userAgent))
	}
	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodPost, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIDeleteUptimeTestRequest represents a request type.
type APIDeleteUptimeTestRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	testId     string
}

// Execute executes the request.
func (r APIDeleteUptimeTestRequest) Execute() error {
	return r.APIService.DeleteUptimeTestExecute(r)
}

// DeleteUptimeTest Delete an uptime check.
func (a *UptimeService) DeleteUptimeTest(ctx context.Context, testId string) APIDeleteUptimeTestRequest {
	return APIDeleteUptimeTestRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// DeleteUptimeTestWithData Delete an uptime check.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *UptimeService) DeleteUptimeTestWithData(ctx context.Context, testId string, m map[string]interface{}) APIDeleteUptimeTestRequest {
	r := a.DeleteUptimeTest(ctx, testId)
	return r
}

// Execute executes the request.
func (a *UptimeService) DeleteUptimeTestExecute(r APIDeleteUptimeTestRequest) error {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "UptimeService.DeleteUptimeTest")
	if err != nil {
		return err
	}

	requestPath := basePath + "/uptime/{test_id}"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodDelete, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return v
	}

	return nil
}

// APIGetUptimeTestRequest represents a request type.
type APIGetUptimeTestRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	testId     string
}

// Execute executes the request.
func (r APIGetUptimeTestRequest) Execute() (UptimeTestResponse, error) {
	return r.APIService.GetUptimeTestExecute(r)
}

// GetUptimeTest Retrieve an uptime check.
func (a *UptimeService) GetUptimeTest(ctx context.Context, testId string) APIGetUptimeTestRequest {
	return APIGetUptimeTestRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// GetUptimeTestWithData Retrieve an uptime check.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *UptimeService) GetUptimeTestWithData(ctx context.Context, testId string, m map[string]interface{}) APIGetUptimeTestRequest {
	r := a.GetUptimeTest(ctx, testId)
	return r
}

// Execute executes the request.
func (a *UptimeService) GetUptimeTestExecute(r APIGetUptimeTestRequest) (UptimeTestResponse, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          UptimeTestResponse
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "UptimeService.GetUptimeTest")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime/{test_id}"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIListMaintenanceWindowsRequest represents a request type.
type APIListMaintenanceWindowsRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	state      *string
}

// State sets state on the request type.
func (r APIListMaintenanceWindowsRequest) State(state string) APIListMaintenanceWindowsRequest {
	r.state = &state
	return r
}

// Execute executes the request.
func (r APIListMaintenanceWindowsRequest) Execute() (MaintenanceWindows, error) {
	return r.APIService.ListMaintenanceWindowsExecute(r)
}

// ListMaintenanceWindows Get all maintenance windows.
func (a *UptimeService) ListMaintenanceWindows(ctx context.Context) APIListMaintenanceWindowsRequest {
	return APIListMaintenanceWindowsRequest{
		ctx:        ctx,
		APIService: a,
	}
}

// ListMaintenanceWindowsWithData Get all maintenance windows.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *UptimeService) ListMaintenanceWindowsWithData(ctx context.Context, m map[string]interface{}) APIListMaintenanceWindowsRequest {
	r := a.ListMaintenanceWindows(ctx)
	return r
}

// Execute executes the request.
func (a *UptimeService) ListMaintenanceWindowsExecute(r APIListMaintenanceWindowsRequest) (MaintenanceWindows, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          MaintenanceWindows
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "UptimeService.ListMaintenanceWindows")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/maintenance-windows"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.state != nil {
		queryParams.Add("state", parameterToString(*r.state))
	}
	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIListUptimeTestAlertsRequest represents a request type.
type APIListUptimeTestAlertsRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	testId     string
	start      *int64
	limit      *int32
}

// Start sets start on the request type.
func (r APIListUptimeTestAlertsRequest) Start(start int64) APIListUptimeTestAlertsRequest {
	r.start = &start
	return r
}

// Limit sets limit on the request type.
func (r APIListUptimeTestAlertsRequest) Limit(limit int32) APIListUptimeTestAlertsRequest {
	r.limit = &limit
	return r
}

// Execute executes the request.
func (r APIListUptimeTestAlertsRequest) Execute() (UptimeTestAlerts, error) {
	return r.APIService.ListUptimeTestAlertsExecute(r)
}

// ListUptimeTestAlerts Get all uptime check alerts.
func (a *UptimeService) ListUptimeTestAlerts(ctx context.Context, testId string) APIListUptimeTestAlertsRequest {
	return APIListUptimeTestAlertsRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// ListUptimeTestAlertsWithData Get all uptime check alerts.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *UptimeService) ListUptimeTestAlertsWithData(ctx context.Context, testId string, m map[string]interface{}) APIListUptimeTestAlertsRequest {
	r := a.ListUptimeTestAlerts(ctx, testId)
	return r
}

// Execute executes the request.
func (a *UptimeService) ListUptimeTestAlertsExecute(r APIListUptimeTestAlertsRequest) (UptimeTestAlerts, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          UptimeTestAlerts
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "UptimeService.ListUptimeTestAlerts")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime/{test_id}/alerts"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.start != nil {
		queryParams.Add("start", parameterToString(*r.start))
	}
	if r.limit != nil {
		queryParams.Add("limit", parameterToString(*r.limit))
	}
	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIListUptimeTestHistoryRequest represents a request type.
type APIListUptimeTestHistoryRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	testId     string
	start      *int64
	end        *int64
	limit      *int32
}

// Start sets start on the request type.
func (r APIListUptimeTestHistoryRequest) Start(start int64) APIListUptimeTestHistoryRequest {
	r.start = &start
	return r
}

// End sets end on the request type.
func (r APIListUptimeTestHistoryRequest) End(end int64) APIListUptimeTestHistoryRequest {
	r.end = &end
	return r
}

// Limit sets limit on the request type.
func (r APIListUptimeTestHistoryRequest) Limit(limit int32) APIListUptimeTestHistoryRequest {
	r.limit = &limit
	return r
}

// Execute executes the request.
func (r APIListUptimeTestHistoryRequest) Execute() (UptimeTestHistory, error) {
	return r.APIService.ListUptimeTestHistoryExecute(r)
}

// ListUptimeTestHistory Get all uptime check history.
func (a *UptimeService) ListUptimeTestHistory(ctx context.Context, testId string) APIListUptimeTestHistoryRequest {
	return APIListUptimeTestHistoryRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// ListUptimeTestHistoryWithData Get all uptime check history.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *UptimeService) ListUptimeTestHistoryWithData(ctx context.Context, testId string, m map[string]interface{}) APIListUptimeTestHistoryRequest {
	r := a.ListUptimeTestHistory(ctx, testId)
	return r
}

// Execute executes the request.
func (a *UptimeService) ListUptimeTestHistoryExecute(r APIListUptimeTestHistoryRequest) (UptimeTestHistory, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          UptimeTestHistory
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "UptimeService.ListUptimeTestHistory")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime/{test_id}/history"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.start != nil {
		queryParams.Add("start", parameterToString(*r.start))
	}
	if r.end != nil {
		queryParams.Add("end", parameterToString(*r.end))
	}
	if r.limit != nil {
		queryParams.Add("limit", parameterToString(*r.limit))
	}
	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIListUptimeTestPeriodsRequest represents a request type.
type APIListUptimeTestPeriodsRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	testId     string
}

// Execute executes the request.
func (r APIListUptimeTestPeriodsRequest) Execute() (UptimeTestPeriods, error) {
	return r.APIService.ListUptimeTestPeriodsExecute(r)
}

// ListUptimeTestPeriods Get all uptime check periods.
func (a *UptimeService) ListUptimeTestPeriods(ctx context.Context, testId string) APIListUptimeTestPeriodsRequest {
	return APIListUptimeTestPeriodsRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// ListUptimeTestPeriodsWithData Get all uptime check periods.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *UptimeService) ListUptimeTestPeriodsWithData(ctx context.Context, testId string, m map[string]interface{}) APIListUptimeTestPeriodsRequest {
	r := a.ListUptimeTestPeriods(ctx, testId)
	return r
}

// Execute executes the request.
func (a *UptimeService) ListUptimeTestPeriodsExecute(r APIListUptimeTestPeriodsRequest) (UptimeTestPeriods, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          UptimeTestPeriods
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "UptimeService.ListUptimeTestPeriods")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime/{test_id}/periods"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIListUptimeTestsRequest represents a request type.
type APIListUptimeTestsRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	status     *string
	page       *int32
	limit      *int32
	tags       *string
	matchany   *bool
	nouptime   *bool
}

// Status sets status on the request type.
func (r APIListUptimeTestsRequest) Status(status string) APIListUptimeTestsRequest {
	r.status = &status
	return r
}

// Page sets page on the request type.
func (r APIListUptimeTestsRequest) Page(page int32) APIListUptimeTestsRequest {
	r.page = &page
	return r
}

// Limit sets limit on the request type.
func (r APIListUptimeTestsRequest) Limit(limit int32) APIListUptimeTestsRequest {
	r.limit = &limit
	return r
}

// Tags sets tags on the request type.
func (r APIListUptimeTestsRequest) Tags(tags string) APIListUptimeTestsRequest {
	r.tags = &tags
	return r
}

// Matchany sets matchany on the request type.
func (r APIListUptimeTestsRequest) Matchany(matchany bool) APIListUptimeTestsRequest {
	r.matchany = &matchany
	return r
}

// Nouptime sets nouptime on the request type.
func (r APIListUptimeTestsRequest) Nouptime(nouptime bool) APIListUptimeTestsRequest {
	r.nouptime = &nouptime
	return r
}

// Execute executes the request.
func (r APIListUptimeTestsRequest) Execute() (UptimeTests, error) {
	return r.APIService.ListUptimeTestsExecute(r)
}

// ListUptimeTests Get all uptime checks.
func (a *UptimeService) ListUptimeTests(ctx context.Context) APIListUptimeTestsRequest {
	return APIListUptimeTestsRequest{
		ctx:        ctx,
		APIService: a,
	}
}

// ListUptimeTestsWithData Get all uptime checks.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *UptimeService) ListUptimeTestsWithData(ctx context.Context, m map[string]interface{}) APIListUptimeTestsRequest {
	r := a.ListUptimeTests(ctx)
	return r
}

// Execute executes the request.
func (a *UptimeService) ListUptimeTestsExecute(r APIListUptimeTestsRequest) (UptimeTests, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          UptimeTests
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "UptimeService.ListUptimeTests")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.status != nil {
		queryParams.Add("status", parameterToString(*r.status))
	}
	if r.page != nil {
		queryParams.Add("page", parameterToString(*r.page))
	}
	if r.limit != nil {
		queryParams.Add("limit", parameterToString(*r.limit))
	}
	if r.tags != nil {
		queryParams.Add("tags", parameterToString(*r.tags))
	}
	if r.matchany != nil {
		queryParams.Add("matchany", parameterToString(*r.matchany))
	}
	if r.nouptime != nil {
		queryParams.Add("nouptime", parameterToString(*r.nouptime))
	}
	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIUpdateUptimeTestRequest represents a request type.
type APIUpdateUptimeTestRequest struct {
	ctx              context.Context
	APIService       UptimeAPI
	testId           string
	name             *string
	checkRate        *UptimeTestCheckRate
	basicUsername    *string
	basicPassword    *string
	confirmation     *int32
	contactGroups    *[]string
	contactGroupsCsv *string
	customHeader     *string
	doNotFind        *bool
	dnsIps           *[]string
	dnsIpsCsv        *string
	dnsServer        *string
	enableSslAlert   *bool
	finalEndpoint    *string
	findString       *string
	followRedirects  *bool
	host             *string
	includeHeader    *bool
	paused           *bool
	port             *int32
	postBody         *string
	postRaw          *string
	regions          *[]string
	statusCodesCsv   *string
	tags             *[]string
	tagsCsv          *string
	timeout          *int32
	triggerRate      *int32
	useJar           *bool
	userAgent        *string
}

// Name sets name on the request type.
func (r APIUpdateUptimeTestRequest) Name(name string) APIUpdateUptimeTestRequest {
	r.name = &name
	return r
}

// CheckRate sets checkRate on the request type.
func (r APIUpdateUptimeTestRequest) CheckRate(checkRate UptimeTestCheckRate) APIUpdateUptimeTestRequest {
	r.checkRate = &checkRate
	return r
}

// BasicUsername sets basicUsername on the request type.
func (r APIUpdateUptimeTestRequest) BasicUsername(basicUsername string) APIUpdateUptimeTestRequest {
	r.basicUsername = &basicUsername
	return r
}

// BasicPassword sets basicPassword on the request type.
func (r APIUpdateUptimeTestRequest) BasicPassword(basicPassword string) APIUpdateUptimeTestRequest {
	r.basicPassword = &basicPassword
	return r
}

// Confirmation sets confirmation on the request type.
func (r APIUpdateUptimeTestRequest) Confirmation(confirmation int32) APIUpdateUptimeTestRequest {
	r.confirmation = &confirmation
	return r
}

// ContactGroups sets contactGroups on the request type.
func (r APIUpdateUptimeTestRequest) ContactGroups(contactGroups []string) APIUpdateUptimeTestRequest {
	r.contactGroups = &contactGroups
	return r
}

// ContactGroupsCsv sets contactGroupsCsv on the request type.
func (r APIUpdateUptimeTestRequest) ContactGroupsCsv(contactGroupsCsv string) APIUpdateUptimeTestRequest {
	r.contactGroupsCsv = &contactGroupsCsv
	return r
}

// CustomHeader sets customHeader on the request type.
func (r APIUpdateUptimeTestRequest) CustomHeader(customHeader string) APIUpdateUptimeTestRequest {
	r.customHeader = &customHeader
	return r
}

// DoNotFind sets doNotFind on the request type.
func (r APIUpdateUptimeTestRequest) DoNotFind(doNotFind bool) APIUpdateUptimeTestRequest {
	r.doNotFind = &doNotFind
	return r
}

// DNSIPs sets dnsIps on the request type.
func (r APIUpdateUptimeTestRequest) DNSIPs(dnsIps []string) APIUpdateUptimeTestRequest {
	r.dnsIps = &dnsIps
	return r
}

// DnsIpsCsv sets dnsIpsCsv on the request type.
func (r APIUpdateUptimeTestRequest) DnsIpsCsv(dnsIpsCsv string) APIUpdateUptimeTestRequest {
	r.dnsIpsCsv = &dnsIpsCsv
	return r
}

// DNSServer sets dnsServer on the request type.
func (r APIUpdateUptimeTestRequest) DNSServer(dnsServer string) APIUpdateUptimeTestRequest {
	r.dnsServer = &dnsServer
	return r
}

// EnableSSLAlert sets enableSslAlert on the request type.
func (r APIUpdateUptimeTestRequest) EnableSSLAlert(enableSslAlert bool) APIUpdateUptimeTestRequest {
	r.enableSslAlert = &enableSslAlert
	return r
}

// FinalEndpoint sets finalEndpoint on the request type.
func (r APIUpdateUptimeTestRequest) FinalEndpoint(finalEndpoint string) APIUpdateUptimeTestRequest {
	r.finalEndpoint = &finalEndpoint
	return r
}

// FindString sets findString on the request type.
func (r APIUpdateUptimeTestRequest) FindString(findString string) APIUpdateUptimeTestRequest {
	r.findString = &findString
	return r
}

// FollowRedirects sets followRedirects on the request type.
func (r APIUpdateUptimeTestRequest) FollowRedirects(followRedirects bool) APIUpdateUptimeTestRequest {
	r.followRedirects = &followRedirects
	return r
}

// Host sets host on the request type.
func (r APIUpdateUptimeTestRequest) Host(host string) APIUpdateUptimeTestRequest {
	r.host = &host
	return r
}

// IncludeHeader sets includeHeader on the request type.
func (r APIUpdateUptimeTestRequest) IncludeHeader(includeHeader bool) APIUpdateUptimeTestRequest {
	r.includeHeader = &includeHeader
	return r
}

// Paused sets paused on the request type.
func (r APIUpdateUptimeTestRequest) Paused(paused bool) APIUpdateUptimeTestRequest {
	r.paused = &paused
	return r
}

// Port sets port on the request type.
func (r APIUpdateUptimeTestRequest) Port(port int32) APIUpdateUptimeTestRequest {
	r.port = &port
	return r
}

// PostBody sets postBody on the request type.
func (r APIUpdateUptimeTestRequest) PostBody(postBody string) APIUpdateUptimeTestRequest {
	r.postBody = &postBody
	return r
}

// PostRaw sets postRaw on the request type.
func (r APIUpdateUptimeTestRequest) PostRaw(postRaw string) APIUpdateUptimeTestRequest {
	r.postRaw = &postRaw
	return r
}

// Regions sets regions on the request type.
func (r APIUpdateUptimeTestRequest) Regions(regions []string) APIUpdateUptimeTestRequest {
	r.regions = &regions
	return r
}

// StatusCodes sets statusCodesCsv on the request type.
func (r APIUpdateUptimeTestRequest) StatusCodes(statusCodesCsv []string) APIUpdateUptimeTestRequest {
	r.statusCodesCsv = PtrString(strings.Join(statusCodesCsv, ","))
	return r
}

// Tags sets tags on the request type.
func (r APIUpdateUptimeTestRequest) Tags(tags []string) APIUpdateUptimeTestRequest {
	r.tags = &tags
	return r
}

// TagsCsv sets tagsCsv on the request type.
func (r APIUpdateUptimeTestRequest) TagsCsv(tagsCsv string) APIUpdateUptimeTestRequest {
	r.tagsCsv = &tagsCsv
	return r
}

// Timeout sets timeout on the request type.
func (r APIUpdateUptimeTestRequest) Timeout(timeout int32) APIUpdateUptimeTestRequest {
	r.timeout = &timeout
	return r
}

// TriggerRate sets triggerRate on the request type.
func (r APIUpdateUptimeTestRequest) TriggerRate(triggerRate int32) APIUpdateUptimeTestRequest {
	r.triggerRate = &triggerRate
	return r
}

// UseJAR sets useJar on the request type.
func (r APIUpdateUptimeTestRequest) UseJAR(useJar bool) APIUpdateUptimeTestRequest {
	r.useJar = &useJar
	return r
}

// UserAgent sets userAgent on the request type.
func (r APIUpdateUptimeTestRequest) UserAgent(userAgent string) APIUpdateUptimeTestRequest {
	r.userAgent = &userAgent
	return r
}

// Execute executes the request.
func (r APIUpdateUptimeTestRequest) Execute() error {
	return r.APIService.UpdateUptimeTestExecute(r)
}

// UpdateUptimeTest Update an uptime check.
func (a *UptimeService) UpdateUptimeTest(ctx context.Context, testId string) APIUpdateUptimeTestRequest {
	return APIUpdateUptimeTestRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// UpdateUptimeTestWithData Update an uptime check.
// The use of this method is discouraged as it does not provide the level of
// type safety afforded by the field methods on the request type.
func (a *UptimeService) UpdateUptimeTestWithData(ctx context.Context, testId string, m map[string]interface{}) APIUpdateUptimeTestRequest {
	r := a.UpdateUptimeTest(ctx, testId)

	if prop, ok := m["name"].(string); ok {
		r.name = &prop
	}

	if prop, ok := m["check_rate"].(UptimeTestCheckRate); ok {
		r.checkRate = &prop
	}

	if prop, ok := m["basic_username"].(string); ok {
		r.basicUsername = &prop
	}

	if prop, ok := m["basic_password"].(string); ok {
		r.basicPassword = &prop
	}

	if prop, ok := m["confirmation"].(int32); ok {
		r.confirmation = &prop
	}

	if prop, ok := m["contact_groups"].([]string); ok {
		r.contactGroups = &prop
	}

	if prop, ok := m["contact_groups_csv"].(string); ok {
		r.contactGroupsCsv = &prop
	}

	if prop, ok := m["custom_header"].(string); ok {
		r.customHeader = &prop
	}

	if prop, ok := m["do_not_find"].(bool); ok {
		r.doNotFind = &prop
	}

	if prop, ok := m["dns_ips"].([]string); ok {
		r.dnsIps = &prop
	}

	if prop, ok := m["dns_ips_csv"].(string); ok {
		r.dnsIpsCsv = &prop
	}

	if prop, ok := m["dns_server"].(string); ok {
		r.dnsServer = &prop
	}

	if prop, ok := m["enable_ssl_alert"].(bool); ok {
		r.enableSslAlert = &prop
	}

	if prop, ok := m["final_endpoint"].(string); ok {
		r.finalEndpoint = &prop
	}

	if prop, ok := m["find_string"].(string); ok {
		r.findString = &prop
	}

	if prop, ok := m["follow_redirects"].(bool); ok {
		r.followRedirects = &prop
	}

	if prop, ok := m["host"].(string); ok {
		r.host = &prop
	}

	if prop, ok := m["include_header"].(bool); ok {
		r.includeHeader = &prop
	}

	if prop, ok := m["paused"].(bool); ok {
		r.paused = &prop
	}

	if prop, ok := m["port"].(int32); ok {
		r.port = &prop
	}

	if prop, ok := m["post_body"].(string); ok {
		r.postBody = &prop
	}

	if prop, ok := m["post_raw"].(string); ok {
		r.postRaw = &prop
	}

	if prop, ok := m["regions"].([]string); ok {
		r.regions = &prop
	}

	if prop, ok := m["status_codes_csv"].(string); ok {
		r.statusCodesCsv = &prop
	}

	if prop, ok := m["tags"].([]string); ok {
		r.tags = &prop
	}

	if prop, ok := m["tags_csv"].(string); ok {
		r.tagsCsv = &prop
	}

	if prop, ok := m["timeout"].(int32); ok {
		r.timeout = &prop
	}

	if prop, ok := m["trigger_rate"].(int32); ok {
		r.triggerRate = &prop
	}

	if prop, ok := m["use_jar"].(bool); ok {
		r.useJar = &prop
	}

	if prop, ok := m["user_agent"].(string); ok {
		r.userAgent = &prop
	}

	return r
}

// Execute executes the request.
func (a *UptimeService) UpdateUptimeTestExecute(r APIUpdateUptimeTestRequest) error {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
	)

	basePath, err := a.client.ServerURLWithContext(r.ctx, "UptimeService.UpdateUptimeTest")
	if err != nil {
		return err
	}

	requestPath := basePath + "/uptime/{test_id}"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{"application/x-www-form-urlencoded"}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	if r.name != nil {
		formParams.Add("name", parameterToString(*r.name))
	}

	if r.checkRate != nil {
		formParams.Add("check_rate", parameterToString(*r.checkRate))
	}

	if r.basicUsername != nil {
		formParams.Add("basic_username", parameterToString(*r.basicUsername))
	}

	if r.basicPassword != nil {
		formParams.Add("basic_password", parameterToString(*r.basicPassword))
	}

	if r.confirmation != nil {
		formParams.Add("confirmation", parameterToString(*r.confirmation))
	}

	if r.contactGroups != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.contactGroups) == 0 {
			formParams.Add("contact_groups[]", "")
		}
		for _, val := range *r.contactGroups {
			formParams.Add("contact_groups[]", parameterToString(val))
		}
	}

	if r.contactGroupsCsv != nil {
		formParams.Add("contact_groups_csv", parameterToString(*r.contactGroupsCsv))
	}

	if r.customHeader != nil {
		formParams.Add("custom_header", parameterToString(*r.customHeader))
	}

	if r.doNotFind != nil {
		formParams.Add("do_not_find", parameterToString(*r.doNotFind))
	}

	if r.dnsIps != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.dnsIps) == 0 {
			formParams.Add("dns_ips[]", "")
		}
		for _, val := range *r.dnsIps {
			formParams.Add("dns_ips[]", parameterToString(val))
		}
	}

	if r.dnsIpsCsv != nil {
		formParams.Add("dns_ips_csv", parameterToString(*r.dnsIpsCsv))
	}

	if r.dnsServer != nil {
		formParams.Add("dns_server", parameterToString(*r.dnsServer))
	}

	if r.enableSslAlert != nil {
		formParams.Add("enable_ssl_alert", parameterToString(*r.enableSslAlert))
	}

	if r.finalEndpoint != nil {
		formParams.Add("final_endpoint", parameterToString(*r.finalEndpoint))
	}

	if r.findString != nil {
		formParams.Add("find_string", parameterToString(*r.findString))
	}

	if r.followRedirects != nil {
		formParams.Add("follow_redirects", parameterToString(*r.followRedirects))
	}

	if r.host != nil {
		formParams.Add("host", parameterToString(*r.host))
	}

	if r.includeHeader != nil {
		formParams.Add("include_header", parameterToString(*r.includeHeader))
	}

	if r.paused != nil {
		formParams.Add("paused", parameterToString(*r.paused))
	}

	if r.port != nil {
		formParams.Add("port", parameterToString(*r.port))
	}

	if r.postBody != nil {
		formParams.Add("post_body", parameterToString(*r.postBody))
	}

	if r.postRaw != nil {
		formParams.Add("post_raw", parameterToString(*r.postRaw))
	}

	if r.regions != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.regions) == 0 {
			formParams.Add("regions[]", "")
		}
		for _, val := range *r.regions {
			formParams.Add("regions[]", parameterToString(val))
		}
	}

	if r.statusCodesCsv != nil {
		formParams.Add("status_codes_csv", parameterToString(*r.statusCodesCsv))
	}

	if r.tags != nil {
		// Explicity empty array. This indictes the consumer intended to pass an
		// empty value and therefore likely want to nullify the field.
		if len(*r.tags) == 0 {
			formParams.Add("tags[]", "")
		}
		for _, val := range *r.tags {
			formParams.Add("tags[]", parameterToString(val))
		}
	}

	if r.tagsCsv != nil {
		formParams.Add("tags_csv", parameterToString(*r.tagsCsv))
	}

	if r.timeout != nil {
		formParams.Add("timeout", parameterToString(*r.timeout))
	}

	if r.triggerRate != nil {
		formParams.Add("trigger_rate", parameterToString(*r.triggerRate))
	}

	if r.useJar != nil {
		formParams.Add("use_jar", parameterToString(*r.useJar))
	}

	if r.userAgent != nil {
		formParams.Add("user_agent", parameterToString(*r.userAgent))
	}
	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodPut, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return v
	}

	return nil
}
