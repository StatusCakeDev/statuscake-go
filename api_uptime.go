/*
 * StatusCake API
 *
 * Copyright (c) 2021 StatusCake
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * API version: 1.0.0-beta.1
 * Contact: support@statuscake.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package statuscake

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// Linger please
var _ context.Context

// UptimeAPI describes the necessary methods to adhere to this interface.
type UptimeAPI interface {
	CreateMaintenanceWindow(ctx context.Context) APICreateMaintenanceWindowRequest
	CreateMaintenanceWindowExecute(r APICreateMaintenanceWindowRequest) (APIResponse, error)
	CreateUptimeTest(ctx context.Context) APICreateUptimeTestRequest
	CreateUptimeTestExecute(r APICreateUptimeTestRequest) (APIResponse, error)
	DeleteMaintenanceWindow(ctx context.Context, windowId string) APIDeleteMaintenanceWindowRequest
	DeleteMaintenanceWindowExecute(r APIDeleteMaintenanceWindowRequest) error
	DeleteUptimeTest(ctx context.Context, testId string) APIDeleteUptimeTestRequest
	DeleteUptimeTestExecute(r APIDeleteUptimeTestRequest) error
	GetMaintenanceWindow(ctx context.Context, windowId string) APIGetMaintenanceWindowRequest
	GetMaintenanceWindowExecute(r APIGetMaintenanceWindowRequest) (MaintenanceWindowResponse, error)
	GetUptimeTest(ctx context.Context, testId string) APIGetUptimeTestRequest
	GetUptimeTestExecute(r APIGetUptimeTestRequest) (UptimeTestResponse, error)
	ListMaintenanceWindows(ctx context.Context) APIListMaintenanceWindowsRequest
	ListMaintenanceWindowsExecute(r APIListMaintenanceWindowsRequest) (MaintenanceWindows, error)
	ListSentAlerts(ctx context.Context, testId string) APIListSentAlertsRequest
	ListSentAlertsExecute(r APIListSentAlertsRequest) (UptimeTestAlerts, error)
	ListUptimeTestHistory(ctx context.Context, testId string) APIListUptimeTestHistoryRequest
	ListUptimeTestHistoryExecute(r APIListUptimeTestHistoryRequest) (UptimeTestHistory, error)
	ListUptimeTestPeriods(ctx context.Context, testId string) APIListUptimeTestPeriodsRequest
	ListUptimeTestPeriodsExecute(r APIListUptimeTestPeriodsRequest) (UptimeTestPeriods, error)
	ListUptimeTests(ctx context.Context) APIListUptimeTestsRequest
	ListUptimeTestsExecute(r APIListUptimeTestsRequest) (UptimeTests, error)
	UpdateMaintenanceWindow(ctx context.Context, windowId string) APIUpdateMaintenanceWindowRequest
	UpdateMaintenanceWindowExecute(r APIUpdateMaintenanceWindowRequest) error
	UpdateUptimeTest(ctx context.Context, testId string) APIUpdateUptimeTestRequest
	UpdateUptimeTestExecute(r APIUpdateUptimeTestRequest) error
}

// UptimeService Uptime service.
type UptimeService service

// APICreateMaintenanceWindowRequest represents a request type.
type APICreateMaintenanceWindowRequest struct {
	ctx            context.Context
	APIService     UptimeAPI
	name           *string
	startAt        *time.Time
	endAt          *time.Time
	timezone       *string
	repeatInterval *MaintenanceWindowRepeatInterval
	testsCsv       *string
	tagsCsv        *string
}

// Name sets name on the request type.
func (r APICreateMaintenanceWindowRequest) Name(name string) APICreateMaintenanceWindowRequest {
	r.name = &name
	return r
}

// Start sets startAt on the request type.
func (r APICreateMaintenanceWindowRequest) Start(startAt time.Time) APICreateMaintenanceWindowRequest {
	r.startAt = &startAt
	return r
}

// End sets endAt on the request type.
func (r APICreateMaintenanceWindowRequest) End(endAt time.Time) APICreateMaintenanceWindowRequest {
	r.endAt = &endAt
	return r
}

// Timezone sets timezone on the request type.
func (r APICreateMaintenanceWindowRequest) Timezone(timezone string) APICreateMaintenanceWindowRequest {
	r.timezone = &timezone
	return r
}

// RepeatInterval sets repeatInterval on the request type.
func (r APICreateMaintenanceWindowRequest) RepeatInterval(repeatInterval MaintenanceWindowRepeatInterval) APICreateMaintenanceWindowRequest {
	r.repeatInterval = &repeatInterval
	return r
}

// Tests sets testsCsv on the request type.
func (r APICreateMaintenanceWindowRequest) Tests(testsCsv []string) APICreateMaintenanceWindowRequest {
	r.testsCsv = PtrString(strings.Join(testsCsv, ","))
	return r
}

// Tags sets tagsCsv on the request type.
func (r APICreateMaintenanceWindowRequest) Tags(tagsCsv []string) APICreateMaintenanceWindowRequest {
	r.tagsCsv = PtrString(strings.Join(tagsCsv, ","))
	return r
}

// Execute executes the request.
func (r APICreateMaintenanceWindowRequest) Execute() (APIResponse, error) {
	return r.APIService.CreateMaintenanceWindowExecute(r)
}

// CreateMaintenanceWindow Create a maintenance window.
func (a *UptimeService) CreateMaintenanceWindow(ctx context.Context) APICreateMaintenanceWindowRequest {
	return APICreateMaintenanceWindowRequest{
		ctx:        ctx,
		APIService: a,
	}
}

// Execute executes the request.
func (a *UptimeService) CreateMaintenanceWindowExecute(r APICreateMaintenanceWindowRequest) (APIResponse, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          APIResponse
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.CreateMaintenanceWindow")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/maintenance-windows"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.name == nil {
		return returnValue, errorf("name is required and must be specified")
	}

	if r.startAt == nil {
		return returnValue, errorf("startAt is required and must be specified")
	}

	if r.endAt == nil {
		return returnValue, errorf("endAt is required and must be specified")
	}

	if r.timezone == nil {
		return returnValue, errorf("timezone is required and must be specified")
	}

	// Determine the Content-Type header.
	contentTypes := []string{"application/x-www-form-urlencoded"}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	formParams.Add("name", parameterToString(*r.name))
	formParams.Add("start_at", parameterToString(*r.startAt))
	formParams.Add("end_at", parameterToString(*r.endAt))

	if r.repeatInterval != nil {
		formParams.Add("repeat_interval", parameterToString(*r.repeatInterval))
	}

	if r.testsCsv != nil {
		formParams.Add("tests_csv", parameterToString(*r.testsCsv))
	}

	if r.tagsCsv != nil {
		formParams.Add("tags_csv", parameterToString(*r.tagsCsv))
	}
	formParams.Add("timezone", parameterToString(*r.timezone))
	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodPost, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APICreateUptimeTestRequest represents a request type.
type APICreateUptimeTestRequest struct {
	ctx              context.Context
	APIService       UptimeAPI
	name             *string
	testType         *UptimeTestType
	websiteUrl       *string
	checkRate        *UptimeTestCheckRate
	basicUser        *string
	basicPass        *string
	confirmation     *int32
	contactGroupsCsv *string
	customHeader     *string
	doNotFind        *bool
	dnsIpCsv         *string
	dnsServer        *string
	enableSslAlert   *bool
	finalEndpoint    *string
	findString       *string
	followRedirects  *bool
	host             *string
	includeHeader    *bool
	paused           *bool
	port             *int32
	postBody         *string
	postRaw          *string
	regions          *[]string
	statusCodesCsv   *string
	tagsCsv          *string
	timeout          *int32
	triggerRate      *int32
	useJar           *bool
	userAgent        *string
}

// Name sets name on the request type.
func (r APICreateUptimeTestRequest) Name(name string) APICreateUptimeTestRequest {
	r.name = &name
	return r
}

// TestType sets testType on the request type.
func (r APICreateUptimeTestRequest) TestType(testType UptimeTestType) APICreateUptimeTestRequest {
	r.testType = &testType
	return r
}

// WebsiteURL sets websiteUrl on the request type.
func (r APICreateUptimeTestRequest) WebsiteURL(websiteUrl string) APICreateUptimeTestRequest {
	r.websiteUrl = &websiteUrl
	return r
}

// CheckRate sets checkRate on the request type.
func (r APICreateUptimeTestRequest) CheckRate(checkRate UptimeTestCheckRate) APICreateUptimeTestRequest {
	r.checkRate = &checkRate
	return r
}

// BasicUser sets basicUser on the request type.
func (r APICreateUptimeTestRequest) BasicUser(basicUser string) APICreateUptimeTestRequest {
	r.basicUser = &basicUser
	return r
}

// BasicPass sets basicPass on the request type.
func (r APICreateUptimeTestRequest) BasicPass(basicPass string) APICreateUptimeTestRequest {
	r.basicPass = &basicPass
	return r
}

// Confirmation sets confirmation on the request type.
func (r APICreateUptimeTestRequest) Confirmation(confirmation int32) APICreateUptimeTestRequest {
	r.confirmation = &confirmation
	return r
}

// ContactGroups sets contactGroupsCsv on the request type.
func (r APICreateUptimeTestRequest) ContactGroups(contactGroupsCsv []string) APICreateUptimeTestRequest {
	r.contactGroupsCsv = PtrString(strings.Join(contactGroupsCsv, ","))
	return r
}

// CustomHeader sets customHeader on the request type.
func (r APICreateUptimeTestRequest) CustomHeader(customHeader string) APICreateUptimeTestRequest {
	r.customHeader = &customHeader
	return r
}

// DoNotFind sets doNotFind on the request type.
func (r APICreateUptimeTestRequest) DoNotFind(doNotFind bool) APICreateUptimeTestRequest {
	r.doNotFind = &doNotFind
	return r
}

// DNSIPs sets dnsIpCsv on the request type.
func (r APICreateUptimeTestRequest) DNSIPs(dnsIpCsv []string) APICreateUptimeTestRequest {
	r.dnsIpCsv = PtrString(strings.Join(dnsIpCsv, ","))
	return r
}

// DNSServer sets dnsServer on the request type.
func (r APICreateUptimeTestRequest) DNSServer(dnsServer string) APICreateUptimeTestRequest {
	r.dnsServer = &dnsServer
	return r
}

// EnableSSLAlert sets enableSslAlert on the request type.
func (r APICreateUptimeTestRequest) EnableSSLAlert(enableSslAlert bool) APICreateUptimeTestRequest {
	r.enableSslAlert = &enableSslAlert
	return r
}

// FinalEndpoint sets finalEndpoint on the request type.
func (r APICreateUptimeTestRequest) FinalEndpoint(finalEndpoint string) APICreateUptimeTestRequest {
	r.finalEndpoint = &finalEndpoint
	return r
}

// FindString sets findString on the request type.
func (r APICreateUptimeTestRequest) FindString(findString string) APICreateUptimeTestRequest {
	r.findString = &findString
	return r
}

// FollowRedirects sets followRedirects on the request type.
func (r APICreateUptimeTestRequest) FollowRedirects(followRedirects bool) APICreateUptimeTestRequest {
	r.followRedirects = &followRedirects
	return r
}

// Host sets host on the request type.
func (r APICreateUptimeTestRequest) Host(host string) APICreateUptimeTestRequest {
	r.host = &host
	return r
}

// IncludeHeader sets includeHeader on the request type.
func (r APICreateUptimeTestRequest) IncludeHeader(includeHeader bool) APICreateUptimeTestRequest {
	r.includeHeader = &includeHeader
	return r
}

// Paused sets paused on the request type.
func (r APICreateUptimeTestRequest) Paused(paused bool) APICreateUptimeTestRequest {
	r.paused = &paused
	return r
}

// Port sets port on the request type.
func (r APICreateUptimeTestRequest) Port(port int32) APICreateUptimeTestRequest {
	r.port = &port
	return r
}

// PostBody sets postBody on the request type.
func (r APICreateUptimeTestRequest) PostBody(postBody string) APICreateUptimeTestRequest {
	r.postBody = &postBody
	return r
}

// PostRaw sets postRaw on the request type.
func (r APICreateUptimeTestRequest) PostRaw(postRaw string) APICreateUptimeTestRequest {
	r.postRaw = &postRaw
	return r
}

// Regions sets regions on the request type.
func (r APICreateUptimeTestRequest) Regions(regions []string) APICreateUptimeTestRequest {
	r.regions = &regions
	return r
}

// StatusCodes sets statusCodesCsv on the request type.
func (r APICreateUptimeTestRequest) StatusCodes(statusCodesCsv []string) APICreateUptimeTestRequest {
	r.statusCodesCsv = PtrString(strings.Join(statusCodesCsv, ","))
	return r
}

// Tags sets tagsCsv on the request type.
func (r APICreateUptimeTestRequest) Tags(tagsCsv []string) APICreateUptimeTestRequest {
	r.tagsCsv = PtrString(strings.Join(tagsCsv, ","))
	return r
}

// Timeout sets timeout on the request type.
func (r APICreateUptimeTestRequest) Timeout(timeout int32) APICreateUptimeTestRequest {
	r.timeout = &timeout
	return r
}

// TriggerRate sets triggerRate on the request type.
func (r APICreateUptimeTestRequest) TriggerRate(triggerRate int32) APICreateUptimeTestRequest {
	r.triggerRate = &triggerRate
	return r
}

// UseJAR sets useJar on the request type.
func (r APICreateUptimeTestRequest) UseJAR(useJar bool) APICreateUptimeTestRequest {
	r.useJar = &useJar
	return r
}

// UserAgent sets userAgent on the request type.
func (r APICreateUptimeTestRequest) UserAgent(userAgent string) APICreateUptimeTestRequest {
	r.userAgent = &userAgent
	return r
}

// Execute executes the request.
func (r APICreateUptimeTestRequest) Execute() (APIResponse, error) {
	return r.APIService.CreateUptimeTestExecute(r)
}

// CreateUptimeTest Create an uptime test.
func (a *UptimeService) CreateUptimeTest(ctx context.Context) APICreateUptimeTestRequest {
	return APICreateUptimeTestRequest{
		ctx:        ctx,
		APIService: a,
	}
}

// Execute executes the request.
func (a *UptimeService) CreateUptimeTestExecute(r APICreateUptimeTestRequest) (APIResponse, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          APIResponse
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.CreateUptimeTest")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.name == nil {
		return returnValue, errorf("name is required and must be specified")
	}

	if r.testType == nil {
		return returnValue, errorf("testType is required and must be specified")
	}

	if r.websiteUrl == nil {
		return returnValue, errorf("websiteUrl is required and must be specified")
	}

	if r.checkRate == nil {
		return returnValue, errorf("checkRate is required and must be specified")
	}

	// Determine the Content-Type header.
	contentTypes := []string{"application/x-www-form-urlencoded"}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	formParams.Add("name", parameterToString(*r.name))
	formParams.Add("test_type", parameterToString(*r.testType))
	formParams.Add("website_url", parameterToString(*r.websiteUrl))
	formParams.Add("check_rate", parameterToString(*r.checkRate))

	if r.basicUser != nil {
		formParams.Add("basic_user", parameterToString(*r.basicUser))
	}

	if r.basicPass != nil {
		formParams.Add("basic_pass", parameterToString(*r.basicPass))
	}

	if r.confirmation != nil {
		formParams.Add("confirmation", parameterToString(*r.confirmation))
	}

	if r.contactGroupsCsv != nil {
		formParams.Add("contact_groups_csv", parameterToString(*r.contactGroupsCsv))
	}

	if r.customHeader != nil {
		formParams.Add("custom_header", parameterToString(*r.customHeader))
	}

	if r.doNotFind != nil {
		formParams.Add("do_not_find", parameterToString(*r.doNotFind))
	}

	if r.dnsIpCsv != nil {
		formParams.Add("dns_ip_csv", parameterToString(*r.dnsIpCsv))
	}

	if r.dnsServer != nil {
		formParams.Add("dns_server", parameterToString(*r.dnsServer))
	}

	if r.enableSslAlert != nil {
		formParams.Add("enable_ssl_alert", parameterToString(*r.enableSslAlert))
	}

	if r.finalEndpoint != nil {
		formParams.Add("final_endpoint", parameterToString(*r.finalEndpoint))
	}

	if r.findString != nil {
		formParams.Add("find_string", parameterToString(*r.findString))
	}

	if r.followRedirects != nil {
		formParams.Add("follow_redirects", parameterToString(*r.followRedirects))
	}

	if r.host != nil {
		formParams.Add("host", parameterToString(*r.host))
	}

	if r.includeHeader != nil {
		formParams.Add("include_header", parameterToString(*r.includeHeader))
	}

	if r.paused != nil {
		formParams.Add("paused", parameterToString(*r.paused))
	}

	if r.port != nil {
		formParams.Add("port", parameterToString(*r.port))
	}

	if r.postBody != nil {
		formParams.Add("post_body", parameterToString(*r.postBody))
	}

	if r.postRaw != nil {
		formParams.Add("post_raw", parameterToString(*r.postRaw))
	}

	if r.regions != nil {
		for _, val := range *r.regions {
			formParams.Add("regions[]", parameterToString(val))
		}
	}

	if r.statusCodesCsv != nil {
		formParams.Add("status_codes_csv", parameterToString(*r.statusCodesCsv))
	}

	if r.tagsCsv != nil {
		formParams.Add("tags_csv", parameterToString(*r.tagsCsv))
	}

	if r.timeout != nil {
		formParams.Add("timeout", parameterToString(*r.timeout))
	}

	if r.triggerRate != nil {
		formParams.Add("trigger_rate", parameterToString(*r.triggerRate))
	}

	if r.useJar != nil {
		formParams.Add("use_jar", parameterToString(*r.useJar))
	}

	if r.userAgent != nil {
		formParams.Add("user_agent", parameterToString(*r.userAgent))
	}
	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodPost, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIDeleteMaintenanceWindowRequest represents a request type.
type APIDeleteMaintenanceWindowRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	windowId   string
}

// Execute executes the request.
func (r APIDeleteMaintenanceWindowRequest) Execute() error {
	return r.APIService.DeleteMaintenanceWindowExecute(r)
}

// DeleteMaintenanceWindow Delete a maintenance window.
func (a *UptimeService) DeleteMaintenanceWindow(ctx context.Context, windowId string) APIDeleteMaintenanceWindowRequest {
	return APIDeleteMaintenanceWindowRequest{
		ctx:        ctx,
		APIService: a,
		windowId:   windowId,
	}
}

// Execute executes the request.
func (a *UptimeService) DeleteMaintenanceWindowExecute(r APIDeleteMaintenanceWindowRequest) error {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.DeleteMaintenanceWindow")
	if err != nil {
		return err
	}

	requestPath := basePath + "/maintenance-windows/{window_id}"
	requestPath = strings.Replace(requestPath, "{"+"window_id"+"}", url.PathEscape(parameterToString(r.windowId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodDelete, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return v
	}

	return nil
}

// APIDeleteUptimeTestRequest represents a request type.
type APIDeleteUptimeTestRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	testId     string
}

// Execute executes the request.
func (r APIDeleteUptimeTestRequest) Execute() error {
	return r.APIService.DeleteUptimeTestExecute(r)
}

// DeleteUptimeTest Delete an uptime test.
func (a *UptimeService) DeleteUptimeTest(ctx context.Context, testId string) APIDeleteUptimeTestRequest {
	return APIDeleteUptimeTestRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// Execute executes the request.
func (a *UptimeService) DeleteUptimeTestExecute(r APIDeleteUptimeTestRequest) error {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.DeleteUptimeTest")
	if err != nil {
		return err
	}

	requestPath := basePath + "/uptime/{test_id}"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodDelete, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return v
	}

	return nil
}

// APIGetMaintenanceWindowRequest represents a request type.
type APIGetMaintenanceWindowRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	windowId   string
}

// Execute executes the request.
func (r APIGetMaintenanceWindowRequest) Execute() (MaintenanceWindowResponse, error) {
	return r.APIService.GetMaintenanceWindowExecute(r)
}

// GetMaintenanceWindow Retrieve a maintenance window.
func (a *UptimeService) GetMaintenanceWindow(ctx context.Context, windowId string) APIGetMaintenanceWindowRequest {
	return APIGetMaintenanceWindowRequest{
		ctx:        ctx,
		APIService: a,
		windowId:   windowId,
	}
}

// Execute executes the request.
func (a *UptimeService) GetMaintenanceWindowExecute(r APIGetMaintenanceWindowRequest) (MaintenanceWindowResponse, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          MaintenanceWindowResponse
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.GetMaintenanceWindow")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/maintenance-windows/{window_id}"
	requestPath = strings.Replace(requestPath, "{"+"window_id"+"}", url.PathEscape(parameterToString(r.windowId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIGetUptimeTestRequest represents a request type.
type APIGetUptimeTestRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	testId     string
}

// Execute executes the request.
func (r APIGetUptimeTestRequest) Execute() (UptimeTestResponse, error) {
	return r.APIService.GetUptimeTestExecute(r)
}

// GetUptimeTest Retrieve an uptime test.
func (a *UptimeService) GetUptimeTest(ctx context.Context, testId string) APIGetUptimeTestRequest {
	return APIGetUptimeTestRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// Execute executes the request.
func (a *UptimeService) GetUptimeTestExecute(r APIGetUptimeTestRequest) (UptimeTestResponse, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          UptimeTestResponse
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.GetUptimeTest")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime/{test_id}"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIListMaintenanceWindowsRequest represents a request type.
type APIListMaintenanceWindowsRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	state      *string
}

// State sets state on the request type.
func (r APIListMaintenanceWindowsRequest) State(state string) APIListMaintenanceWindowsRequest {
	r.state = &state
	return r
}

// Execute executes the request.
func (r APIListMaintenanceWindowsRequest) Execute() (MaintenanceWindows, error) {
	return r.APIService.ListMaintenanceWindowsExecute(r)
}

// ListMaintenanceWindows Get all maintenance windows.
func (a *UptimeService) ListMaintenanceWindows(ctx context.Context) APIListMaintenanceWindowsRequest {
	return APIListMaintenanceWindowsRequest{
		ctx:        ctx,
		APIService: a,
	}
}

// Execute executes the request.
func (a *UptimeService) ListMaintenanceWindowsExecute(r APIListMaintenanceWindowsRequest) (MaintenanceWindows, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          MaintenanceWindows
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.ListMaintenanceWindows")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/maintenance-windows"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.state != nil {
		queryParams.Add("state", parameterToString(*r.state))
	}
	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIListSentAlertsRequest represents a request type.
type APIListSentAlertsRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	testId     string
	start      *int64
	limit      *int32
}

// Start sets start on the request type.
func (r APIListSentAlertsRequest) Start(start int64) APIListSentAlertsRequest {
	r.start = &start
	return r
}

// Limit sets limit on the request type.
func (r APIListSentAlertsRequest) Limit(limit int32) APIListSentAlertsRequest {
	r.limit = &limit
	return r
}

// Execute executes the request.
func (r APIListSentAlertsRequest) Execute() (UptimeTestAlerts, error) {
	return r.APIService.ListSentAlertsExecute(r)
}

// ListSentAlerts Get all sent uptime alerts.
func (a *UptimeService) ListSentAlerts(ctx context.Context, testId string) APIListSentAlertsRequest {
	return APIListSentAlertsRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// Execute executes the request.
func (a *UptimeService) ListSentAlertsExecute(r APIListSentAlertsRequest) (UptimeTestAlerts, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          UptimeTestAlerts
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.ListSentAlerts")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime/{test_id}/alerts"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.start != nil {
		queryParams.Add("start", parameterToString(*r.start))
	}
	if r.limit != nil {
		queryParams.Add("limit", parameterToString(*r.limit))
	}
	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIListUptimeTestHistoryRequest represents a request type.
type APIListUptimeTestHistoryRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	testId     string
	start      *int64
	end        *int64
	limit      *int32
}

// Start sets start on the request type.
func (r APIListUptimeTestHistoryRequest) Start(start int64) APIListUptimeTestHistoryRequest {
	r.start = &start
	return r
}

// End sets end on the request type.
func (r APIListUptimeTestHistoryRequest) End(end int64) APIListUptimeTestHistoryRequest {
	r.end = &end
	return r
}

// Limit sets limit on the request type.
func (r APIListUptimeTestHistoryRequest) Limit(limit int32) APIListUptimeTestHistoryRequest {
	r.limit = &limit
	return r
}

// Execute executes the request.
func (r APIListUptimeTestHistoryRequest) Execute() (UptimeTestHistory, error) {
	return r.APIService.ListUptimeTestHistoryExecute(r)
}

// ListUptimeTestHistory Get all uptime test history.
func (a *UptimeService) ListUptimeTestHistory(ctx context.Context, testId string) APIListUptimeTestHistoryRequest {
	return APIListUptimeTestHistoryRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// Execute executes the request.
func (a *UptimeService) ListUptimeTestHistoryExecute(r APIListUptimeTestHistoryRequest) (UptimeTestHistory, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          UptimeTestHistory
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.ListUptimeTestHistory")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime/{test_id}/history"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.start != nil {
		queryParams.Add("start", parameterToString(*r.start))
	}
	if r.end != nil {
		queryParams.Add("end", parameterToString(*r.end))
	}
	if r.limit != nil {
		queryParams.Add("limit", parameterToString(*r.limit))
	}
	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIListUptimeTestPeriodsRequest represents a request type.
type APIListUptimeTestPeriodsRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	testId     string
}

// Execute executes the request.
func (r APIListUptimeTestPeriodsRequest) Execute() (UptimeTestPeriods, error) {
	return r.APIService.ListUptimeTestPeriodsExecute(r)
}

// ListUptimeTestPeriods Get all uptime test periods.
func (a *UptimeService) ListUptimeTestPeriods(ctx context.Context, testId string) APIListUptimeTestPeriodsRequest {
	return APIListUptimeTestPeriodsRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// Execute executes the request.
func (a *UptimeService) ListUptimeTestPeriodsExecute(r APIListUptimeTestPeriodsRequest) (UptimeTestPeriods, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          UptimeTestPeriods
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.ListUptimeTestPeriods")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime/{test_id}/periods"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIListUptimeTestsRequest represents a request type.
type APIListUptimeTestsRequest struct {
	ctx        context.Context
	APIService UptimeAPI
	status     *string
	page       *int32
	limit      *int32
	tags       *string
	matchany   *bool
	nouptime   *bool
}

// Status sets status on the request type.
func (r APIListUptimeTestsRequest) Status(status string) APIListUptimeTestsRequest {
	r.status = &status
	return r
}

// Page sets page on the request type.
func (r APIListUptimeTestsRequest) Page(page int32) APIListUptimeTestsRequest {
	r.page = &page
	return r
}

// Limit sets limit on the request type.
func (r APIListUptimeTestsRequest) Limit(limit int32) APIListUptimeTestsRequest {
	r.limit = &limit
	return r
}

// Tags sets tags on the request type.
func (r APIListUptimeTestsRequest) Tags(tags string) APIListUptimeTestsRequest {
	r.tags = &tags
	return r
}

// Matchany sets matchany on the request type.
func (r APIListUptimeTestsRequest) Matchany(matchany bool) APIListUptimeTestsRequest {
	r.matchany = &matchany
	return r
}

// Nouptime sets nouptime on the request type.
func (r APIListUptimeTestsRequest) Nouptime(nouptime bool) APIListUptimeTestsRequest {
	r.nouptime = &nouptime
	return r
}

// Execute executes the request.
func (r APIListUptimeTestsRequest) Execute() (UptimeTests, error) {
	return r.APIService.ListUptimeTestsExecute(r)
}

// ListUptimeTests Get all uptime tests.
func (a *UptimeService) ListUptimeTests(ctx context.Context) APIListUptimeTestsRequest {
	return APIListUptimeTestsRequest{
		ctx:        ctx,
		APIService: a,
	}
}

// Execute executes the request.
func (a *UptimeService) ListUptimeTestsExecute(r APIListUptimeTestsRequest) (UptimeTests, error) {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
		returnValue          UptimeTests
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.ListUptimeTests")
	if err != nil {
		return returnValue, err
	}

	requestPath := basePath + "/uptime"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	if r.status != nil {
		queryParams.Add("status", parameterToString(*r.status))
	}
	if r.page != nil {
		queryParams.Add("page", parameterToString(*r.page))
	}
	if r.limit != nil {
		queryParams.Add("limit", parameterToString(*r.limit))
	}
	if r.tags != nil {
		queryParams.Add("tags", parameterToString(*r.tags))
	}
	if r.matchany != nil {
		queryParams.Add("matchany", parameterToString(*r.matchany))
	}
	if r.nouptime != nil {
		queryParams.Add("nouptime", parameterToString(*r.nouptime))
	}
	// Determine the Content-Type header.
	contentTypes := []string{}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodGet, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return returnValue, err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return returnValue, err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return returnValue, err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return returnValue, APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return returnValue, v
	}

	if err := a.client.decode(&returnValue, responseBody, responseContentType); err != nil {
		return returnValue, APIError{
			Status:  res.StatusCode,
			Message: "failed to deserialise response body",
			parent:  err,
		}
	}

	return returnValue, nil
}

// APIUpdateMaintenanceWindowRequest represents a request type.
type APIUpdateMaintenanceWindowRequest struct {
	ctx            context.Context
	APIService     UptimeAPI
	windowId       string
	name           *string
	startAt        *time.Time
	endAt          *time.Time
	repeatInterval *MaintenanceWindowRepeatInterval
	testsCsv       *string
	tagsCsv        *string
	timezone       *string
}

// Name sets name on the request type.
func (r APIUpdateMaintenanceWindowRequest) Name(name string) APIUpdateMaintenanceWindowRequest {
	r.name = &name
	return r
}

// Start sets startAt on the request type.
func (r APIUpdateMaintenanceWindowRequest) Start(startAt time.Time) APIUpdateMaintenanceWindowRequest {
	r.startAt = &startAt
	return r
}

// End sets endAt on the request type.
func (r APIUpdateMaintenanceWindowRequest) End(endAt time.Time) APIUpdateMaintenanceWindowRequest {
	r.endAt = &endAt
	return r
}

// RepeatInterval sets repeatInterval on the request type.
func (r APIUpdateMaintenanceWindowRequest) RepeatInterval(repeatInterval MaintenanceWindowRepeatInterval) APIUpdateMaintenanceWindowRequest {
	r.repeatInterval = &repeatInterval
	return r
}

// Tests sets testsCsv on the request type.
func (r APIUpdateMaintenanceWindowRequest) Tests(testsCsv []string) APIUpdateMaintenanceWindowRequest {
	r.testsCsv = PtrString(strings.Join(testsCsv, ","))
	return r
}

// Tags sets tagsCsv on the request type.
func (r APIUpdateMaintenanceWindowRequest) Tags(tagsCsv []string) APIUpdateMaintenanceWindowRequest {
	r.tagsCsv = PtrString(strings.Join(tagsCsv, ","))
	return r
}

// Timezone sets timezone on the request type.
func (r APIUpdateMaintenanceWindowRequest) Timezone(timezone string) APIUpdateMaintenanceWindowRequest {
	r.timezone = &timezone
	return r
}

// Execute executes the request.
func (r APIUpdateMaintenanceWindowRequest) Execute() error {
	return r.APIService.UpdateMaintenanceWindowExecute(r)
}

// UpdateMaintenanceWindow Update a maintenance window.
func (a *UptimeService) UpdateMaintenanceWindow(ctx context.Context, windowId string) APIUpdateMaintenanceWindowRequest {
	return APIUpdateMaintenanceWindowRequest{
		ctx:        ctx,
		APIService: a,
		windowId:   windowId,
	}
}

// Execute executes the request.
func (a *UptimeService) UpdateMaintenanceWindowExecute(r APIUpdateMaintenanceWindowRequest) error {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.UpdateMaintenanceWindow")
	if err != nil {
		return err
	}

	requestPath := basePath + "/maintenance-windows/{window_id}"
	requestPath = strings.Replace(requestPath, "{"+"window_id"+"}", url.PathEscape(parameterToString(r.windowId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{"application/x-www-form-urlencoded"}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	if r.name != nil {
		formParams.Add("name", parameterToString(*r.name))
	}

	if r.startAt != nil {
		formParams.Add("start_at", parameterToString(*r.startAt))
	}

	if r.endAt != nil {
		formParams.Add("end_at", parameterToString(*r.endAt))
	}

	if r.repeatInterval != nil {
		formParams.Add("repeat_interval", parameterToString(*r.repeatInterval))
	}

	if r.testsCsv != nil {
		formParams.Add("tests_csv", parameterToString(*r.testsCsv))
	}

	if r.tagsCsv != nil {
		formParams.Add("tags_csv", parameterToString(*r.tagsCsv))
	}

	if r.timezone != nil {
		formParams.Add("timezone", parameterToString(*r.timezone))
	}
	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodPut, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return v
	}

	return nil
}

// APIUpdateUptimeTestRequest represents a request type.
type APIUpdateUptimeTestRequest struct {
	ctx              context.Context
	APIService       UptimeAPI
	testId           string
	basicUser        *string
	basicPass        *string
	checkRate        *UptimeTestCheckRate
	confirmation     *int32
	contactGroupsCsv *string
	customHeader     *string
	doNotFind        *bool
	dnsIpCsv         *string
	dnsServer        *string
	enableSslAlert   *bool
	finalEndpoint    *string
	findString       *string
	followRedirects  *bool
	host             *string
	includeHeader    *bool
	name             *string
	paused           *bool
	port             *int32
	postBody         *string
	postRaw          *string
	regions          *[]string
	statusCodesCsv   *string
	tagsCsv          *string
	timeout          *int32
	triggerRate      *int32
	useJar           *bool
	userAgent        *string
}

// BasicUser sets basicUser on the request type.
func (r APIUpdateUptimeTestRequest) BasicUser(basicUser string) APIUpdateUptimeTestRequest {
	r.basicUser = &basicUser
	return r
}

// BasicPass sets basicPass on the request type.
func (r APIUpdateUptimeTestRequest) BasicPass(basicPass string) APIUpdateUptimeTestRequest {
	r.basicPass = &basicPass
	return r
}

// CheckRate sets checkRate on the request type.
func (r APIUpdateUptimeTestRequest) CheckRate(checkRate UptimeTestCheckRate) APIUpdateUptimeTestRequest {
	r.checkRate = &checkRate
	return r
}

// Confirmation sets confirmation on the request type.
func (r APIUpdateUptimeTestRequest) Confirmation(confirmation int32) APIUpdateUptimeTestRequest {
	r.confirmation = &confirmation
	return r
}

// ContactGroups sets contactGroupsCsv on the request type.
func (r APIUpdateUptimeTestRequest) ContactGroups(contactGroupsCsv []string) APIUpdateUptimeTestRequest {
	r.contactGroupsCsv = PtrString(strings.Join(contactGroupsCsv, ","))
	return r
}

// CustomHeader sets customHeader on the request type.
func (r APIUpdateUptimeTestRequest) CustomHeader(customHeader string) APIUpdateUptimeTestRequest {
	r.customHeader = &customHeader
	return r
}

// DoNotFind sets doNotFind on the request type.
func (r APIUpdateUptimeTestRequest) DoNotFind(doNotFind bool) APIUpdateUptimeTestRequest {
	r.doNotFind = &doNotFind
	return r
}

// DNSIPs sets dnsIpCsv on the request type.
func (r APIUpdateUptimeTestRequest) DNSIPs(dnsIpCsv []string) APIUpdateUptimeTestRequest {
	r.dnsIpCsv = PtrString(strings.Join(dnsIpCsv, ","))
	return r
}

// DNSServer sets dnsServer on the request type.
func (r APIUpdateUptimeTestRequest) DNSServer(dnsServer string) APIUpdateUptimeTestRequest {
	r.dnsServer = &dnsServer
	return r
}

// EnableSSLAlert sets enableSslAlert on the request type.
func (r APIUpdateUptimeTestRequest) EnableSSLAlert(enableSslAlert bool) APIUpdateUptimeTestRequest {
	r.enableSslAlert = &enableSslAlert
	return r
}

// FinalEndpoint sets finalEndpoint on the request type.
func (r APIUpdateUptimeTestRequest) FinalEndpoint(finalEndpoint string) APIUpdateUptimeTestRequest {
	r.finalEndpoint = &finalEndpoint
	return r
}

// FindString sets findString on the request type.
func (r APIUpdateUptimeTestRequest) FindString(findString string) APIUpdateUptimeTestRequest {
	r.findString = &findString
	return r
}

// FollowRedirects sets followRedirects on the request type.
func (r APIUpdateUptimeTestRequest) FollowRedirects(followRedirects bool) APIUpdateUptimeTestRequest {
	r.followRedirects = &followRedirects
	return r
}

// Host sets host on the request type.
func (r APIUpdateUptimeTestRequest) Host(host string) APIUpdateUptimeTestRequest {
	r.host = &host
	return r
}

// IncludeHeader sets includeHeader on the request type.
func (r APIUpdateUptimeTestRequest) IncludeHeader(includeHeader bool) APIUpdateUptimeTestRequest {
	r.includeHeader = &includeHeader
	return r
}

// Name sets name on the request type.
func (r APIUpdateUptimeTestRequest) Name(name string) APIUpdateUptimeTestRequest {
	r.name = &name
	return r
}

// Paused sets paused on the request type.
func (r APIUpdateUptimeTestRequest) Paused(paused bool) APIUpdateUptimeTestRequest {
	r.paused = &paused
	return r
}

// Port sets port on the request type.
func (r APIUpdateUptimeTestRequest) Port(port int32) APIUpdateUptimeTestRequest {
	r.port = &port
	return r
}

// PostBody sets postBody on the request type.
func (r APIUpdateUptimeTestRequest) PostBody(postBody string) APIUpdateUptimeTestRequest {
	r.postBody = &postBody
	return r
}

// PostRaw sets postRaw on the request type.
func (r APIUpdateUptimeTestRequest) PostRaw(postRaw string) APIUpdateUptimeTestRequest {
	r.postRaw = &postRaw
	return r
}

// Regions sets regions on the request type.
func (r APIUpdateUptimeTestRequest) Regions(regions []string) APIUpdateUptimeTestRequest {
	r.regions = &regions
	return r
}

// StatusCodes sets statusCodesCsv on the request type.
func (r APIUpdateUptimeTestRequest) StatusCodes(statusCodesCsv []string) APIUpdateUptimeTestRequest {
	r.statusCodesCsv = PtrString(strings.Join(statusCodesCsv, ","))
	return r
}

// Tags sets tagsCsv on the request type.
func (r APIUpdateUptimeTestRequest) Tags(tagsCsv []string) APIUpdateUptimeTestRequest {
	r.tagsCsv = PtrString(strings.Join(tagsCsv, ","))
	return r
}

// Timeout sets timeout on the request type.
func (r APIUpdateUptimeTestRequest) Timeout(timeout int32) APIUpdateUptimeTestRequest {
	r.timeout = &timeout
	return r
}

// TriggerRate sets triggerRate on the request type.
func (r APIUpdateUptimeTestRequest) TriggerRate(triggerRate int32) APIUpdateUptimeTestRequest {
	r.triggerRate = &triggerRate
	return r
}

// UseJAR sets useJar on the request type.
func (r APIUpdateUptimeTestRequest) UseJAR(useJar bool) APIUpdateUptimeTestRequest {
	r.useJar = &useJar
	return r
}

// UserAgent sets userAgent on the request type.
func (r APIUpdateUptimeTestRequest) UserAgent(userAgent string) APIUpdateUptimeTestRequest {
	r.userAgent = &userAgent
	return r
}

// Execute executes the request.
func (r APIUpdateUptimeTestRequest) Execute() error {
	return r.APIService.UpdateUptimeTestExecute(r)
}

// UpdateUptimeTest Update an uptime test.
func (a *UptimeService) UpdateUptimeTest(ctx context.Context, testId string) APIUpdateUptimeTestRequest {
	return APIUpdateUptimeTestRequest{
		ctx:        ctx,
		APIService: a,
		testId:     testId,
	}
}

// Execute executes the request.
func (a *UptimeService) UpdateUptimeTestExecute(r APIUpdateUptimeTestRequest) error {
	var (
		requestBody          interface{}
		requestFormFieldName string
		requestFileName      string
		requestFileBytes     []byte
	)

	basePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UptimeService.UpdateUptimeTest")
	if err != nil {
		return err
	}

	requestPath := basePath + "/uptime/{test_id}"
	requestPath = strings.Replace(requestPath, "{"+"test_id"+"}", url.PathEscape(parameterToString(r.testId)), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := url.Values{}

	// Determine the Content-Type header.
	contentTypes := []string{"application/x-www-form-urlencoded"}

	// Set Content-Type header
	requestContentTypeHeader := selectHeaderContentType(contentTypes)
	if requestContentTypeHeader != "" {
		headerParams["Content-Type"] = requestContentTypeHeader
	}

	// Determine the Accept header.
	accepts := []string{"application/json"}

	// Set Accept header.
	requestAcceptHeader := selectHeaderAccept(accepts)
	if requestAcceptHeader != "" {
		headerParams["Accept"] = requestAcceptHeader
	}

	if r.basicUser != nil {
		formParams.Add("basic_user", parameterToString(*r.basicUser))
	}

	if r.basicPass != nil {
		formParams.Add("basic_pass", parameterToString(*r.basicPass))
	}

	if r.checkRate != nil {
		formParams.Add("check_rate", parameterToString(*r.checkRate))
	}

	if r.confirmation != nil {
		formParams.Add("confirmation", parameterToString(*r.confirmation))
	}

	if r.contactGroupsCsv != nil {
		formParams.Add("contact_groups_csv", parameterToString(*r.contactGroupsCsv))
	}

	if r.customHeader != nil {
		formParams.Add("custom_header", parameterToString(*r.customHeader))
	}

	if r.doNotFind != nil {
		formParams.Add("do_not_find", parameterToString(*r.doNotFind))
	}

	if r.dnsIpCsv != nil {
		formParams.Add("dns_ip_csv", parameterToString(*r.dnsIpCsv))
	}

	if r.dnsServer != nil {
		formParams.Add("dns_server", parameterToString(*r.dnsServer))
	}

	if r.enableSslAlert != nil {
		formParams.Add("enable_ssl_alert", parameterToString(*r.enableSslAlert))
	}

	if r.finalEndpoint != nil {
		formParams.Add("final_endpoint", parameterToString(*r.finalEndpoint))
	}

	if r.findString != nil {
		formParams.Add("find_string", parameterToString(*r.findString))
	}

	if r.followRedirects != nil {
		formParams.Add("follow_redirects", parameterToString(*r.followRedirects))
	}

	if r.host != nil {
		formParams.Add("host", parameterToString(*r.host))
	}

	if r.includeHeader != nil {
		formParams.Add("include_header", parameterToString(*r.includeHeader))
	}

	if r.name != nil {
		formParams.Add("name", parameterToString(*r.name))
	}

	if r.paused != nil {
		formParams.Add("paused", parameterToString(*r.paused))
	}

	if r.port != nil {
		formParams.Add("port", parameterToString(*r.port))
	}

	if r.postBody != nil {
		formParams.Add("post_body", parameterToString(*r.postBody))
	}

	if r.postRaw != nil {
		formParams.Add("post_raw", parameterToString(*r.postRaw))
	}

	if r.regions != nil {
		for _, val := range *r.regions {
			formParams.Add("regions[]", parameterToString(val))
		}
	}

	if r.statusCodesCsv != nil {
		formParams.Add("status_codes_csv", parameterToString(*r.statusCodesCsv))
	}

	if r.tagsCsv != nil {
		formParams.Add("tags_csv", parameterToString(*r.tagsCsv))
	}

	if r.timeout != nil {
		formParams.Add("timeout", parameterToString(*r.timeout))
	}

	if r.triggerRate != nil {
		formParams.Add("trigger_rate", parameterToString(*r.triggerRate))
	}

	if r.useJar != nil {
		formParams.Add("use_jar", parameterToString(*r.useJar))
	}

	if r.userAgent != nil {
		formParams.Add("user_agent", parameterToString(*r.userAgent))
	}
	req, err := a.client.prepareRequest(r.ctx, requestPath, http.MethodPut, requestBody, headerParams, queryParams, formParams, requestFormFieldName, requestFileName, requestFileBytes)
	if err != nil {
		return err
	}

	res, err := a.client.callAPI(req)
	if err != nil || res == nil {
		return err
	}

	responseBody, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	res.Body = ioutil.NopCloser(bytes.NewBuffer(responseBody))
	if err != nil {
		return err
	}

	responseContentType := res.Header.Get("Content-Type")

	if res.StatusCode >= 300 {
		var v APIError
		if err := a.client.decode(&v, responseBody, responseContentType); err != nil {
			return APIError{
				Status:  res.StatusCode,
				Message: "failed to deserialise error response",
				parent:  err,
			}
		}
		v.Status = res.StatusCode
		return v
	}

	return nil
}
